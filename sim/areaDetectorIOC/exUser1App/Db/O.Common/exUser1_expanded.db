#=================================================================#
# Template file: simDetector.template
# Database for the records specific to the simulated detector driver
# Mark Rivers
# March 23, 2008

#=================================================================#
# Template file: ADBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

#  Using SCANRATE:The ImageJ EPICS_AD_Viewer plugin monitors ArrayCounter_RBV to decide 
#  when there is a new image to display. That means that it will not display faster than
#  the SCANRATE you select.

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "ADT:USER1:CAM:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.CAM,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the version of the driver or plugin       #
###################################################################

record(stringin, "ADT:USER1:CAM:DriverVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.CAM,0,1)DRIVER_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "ADT:USER1:CAM:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.CAM,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records contain basic information about the detector     # 
###################################################################

record(stringin, "ADT:USER1:CAM:Manufacturer_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.CAM,0,1)MANUFACTURER")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:CAM:Model_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.CAM,0,1)MODEL")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:CAM:SerialNumber_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.CAM,0,1)SERIAL_NUMBER")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:CAM:SDKVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.CAM,0,1)SDK_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:CAM:FirmwareVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.CAM,0,1)FIRMWARE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control acquisition start and stop               #
###################################################################

record(bo, "ADT:USER1:CAM:Acquire") {
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(SIM.CAM,0,1)ACQUIRE")
   field(ZNAM, "Done")
   field(ONAM, "Acquire")
   field(VAL,  "0")
   field(FLNK, "ADT:USER1:CAM:SetAcquireBusy")
   info(asyn:READBACK, "1")
}

record(bi, "ADT:USER1:CAM:Acquire_RBV") {
   field(DTYP, "asynInt32")
   field(INP, "@asyn(SIM.CAM,0,1)ACQUIRE")
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:CAM:SetAcquireBusy")
{
    field(INPA, "ADT:USER1:CAM:Acquire NPP")
    field(CALC, "A")
    field(OOPT, "Transition To Non-zero")
    field(OUT,  "ADT:USER1:CAM:AcquireBusy PP")
}

record(busy, "ADT:USER1:CAM:AcquireBusy") {
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(VAL,  "0")
}

record(bi, "ADT:USER1:CAM:AcquireBusyCB") {
   field(DTYP, "asynInt32")
   field(INP, "@asyn(SIM.CAM,0,1)ACQUIRE_BUSY")
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:CAM:ClearAcquireBusy") {
    field(INPA, "ADT:USER1:CAM:AcquireBusyCB CP")
    field(CALC, "A")
    field(OOPT, "Transition To Zero")
    field(OUT,  "ADT:USER1:CAM:AcquireBusy PP")
}

record(bo, "ADT:USER1:CAM:WaitForPlugins") {
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(SIM.CAM,0,1)WAIT_FOR_PLUGINS")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(VAL,  "0")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longout, "ADT:USER1:CAM:NDimensions")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.CAM,0,1)ARRAY_NDIMENSIONS")
}

record(longin, "ADT:USER1:CAM:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform records
record(waveform, "ADT:USER1:CAM:Dimensions")
{
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(SIM.CAM,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "ADT:USER1:CAM:Dim0SA")
}

record(subArray, "ADT:USER1:CAM:Dim0SA")
{
    field(INP,  "ADT:USER1:CAM:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "ADT:USER1:CAM:ArraySize0")
}

record(longin, "ADT:USER1:CAM:ArraySize0")
{
    field(INP,  "ADT:USER1:CAM:Dim0SA")
    field(FLNK, "ADT:USER1:CAM:Dim1SA")
}

record(subArray, "ADT:USER1:CAM:Dim1SA")
{
    field(INP,  "ADT:USER1:CAM:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "ADT:USER1:CAM:ArraySize1")
}

record(longin, "ADT:USER1:CAM:ArraySize1")
{
    field(INP,  "ADT:USER1:CAM:Dim1SA")
    field(FLNK, "ADT:USER1:CAM:Dim2SA")
}

record(subArray, "ADT:USER1:CAM:Dim2SA")
{
    field(INP,  "ADT:USER1:CAM:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "ADT:USER1:CAM:ArraySize2")
}

record(longin, "ADT:USER1:CAM:ArraySize2")
{
    field(INP,  "ADT:USER1:CAM:Dim2SA")
    field(FLNK, "ADT:USER1:CAM:Dim3SA")
}

record(subArray, "ADT:USER1:CAM:Dim3SA")
{
    field(INP,  "ADT:USER1:CAM:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "3")
    field(FLNK, "ADT:USER1:CAM:ArraySize3")
}

record(longin, "ADT:USER1:CAM:ArraySize3")
{
    field(INP,  "ADT:USER1:CAM:Dim3SA")
    field(FLNK, "ADT:USER1:CAM:Dim4SA")
}

record(subArray, "ADT:USER1:CAM:Dim4SA")
{
    field(INP,  "ADT:USER1:CAM:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "4")
    field(FLNK, "ADT:USER1:CAM:ArraySize4")
}

record(longin, "ADT:USER1:CAM:ArraySize4")
{
    field(INP,  "ADT:USER1:CAM:Dim4SA")
    field(FLNK, "ADT:USER1:CAM:Dim5SA")
}

record(subArray, "ADT:USER1:CAM:Dim5SA")
{
    field(INP,  "ADT:USER1:CAM:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "5")
    field(FLNK, "ADT:USER1:CAM:ArraySize5")
}

record(longin, "ADT:USER1:CAM:ArraySize5")
{
    field(INP,  "ADT:USER1:CAM:Dim5SA")
    field(FLNK, "ADT:USER1:CAM:Dim6SA")
}

record(subArray, "ADT:USER1:CAM:Dim6SA")
{
    field(INP,  "ADT:USER1:CAM:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "6")
    field(FLNK, "ADT:USER1:CAM:ArraySize6")
}

record(longin, "ADT:USER1:CAM:ArraySize6")
{
    field(INP,  "ADT:USER1:CAM:Dim6SA")
    field(FLNK, "ADT:USER1:CAM:Dim7SA")
}

record(subArray, "ADT:USER1:CAM:Dim7SA")
{
    field(INP,  "ADT:USER1:CAM:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "7")
    field(FLNK, "ADT:USER1:CAM:ArraySize7")
}

record(longin, "ADT:USER1:CAM:ArraySize7")
{
    field(INP,  "ADT:USER1:CAM:Dim7SA")
    field(FLNK, "ADT:USER1:CAM:Dim8SA")
}

record(subArray, "ADT:USER1:CAM:Dim8SA")
{
    field(INP,  "ADT:USER1:CAM:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "8")
    field(FLNK, "ADT:USER1:CAM:ArraySize8")
}

record(longin, "ADT:USER1:CAM:ArraySize8")
{
    field(INP,  "ADT:USER1:CAM:Dim8SA")
    field(FLNK, "ADT:USER1:CAM:Dim9SA")
}

record(subArray, "ADT:USER1:CAM:Dim9SA")
{
    field(INP,  "ADT:USER1:CAM:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "9")
    field(FLNK, "ADT:USER1:CAM:ArraySize9")
}

record(longin, "ADT:USER1:CAM:ArraySize9")
{
    field(INP,  "ADT:USER1:CAM:Dim9SA")
}


record(waveform, "ADT:USER1:CAM:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(SIM.CAM,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "ADT:USER1:CAM:Dim0SA_RBV")
    field(SCAN, "I/O Intr")
}

record(subArray, "ADT:USER1:CAM:Dim0SA_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "ADT:USER1:CAM:ArraySize0_RBV")
}

record(longin, "ADT:USER1:CAM:ArraySize0_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dim0SA_RBV")
    field(FLNK, "ADT:USER1:CAM:Dim1SA_RBV")
}

record(subArray, "ADT:USER1:CAM:Dim1SA_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "ADT:USER1:CAM:ArraySize1_RBV")
}

record(longin, "ADT:USER1:CAM:ArraySize1_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dim1SA_RBV")
    field(FLNK, "ADT:USER1:CAM:Dim2SA_RBV")
}

record(subArray, "ADT:USER1:CAM:Dim2SA_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "ADT:USER1:CAM:ArraySize2_RBV")
}

record(longin, "ADT:USER1:CAM:ArraySize2_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dim2SA_RBV")
    field(FLNK, "ADT:USER1:CAM:Dim3SA_RBV")
}

record(subArray, "ADT:USER1:CAM:Dim3SA_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "3")
    field(FLNK, "ADT:USER1:CAM:ArraySize3_RBV")
}

record(longin, "ADT:USER1:CAM:ArraySize3_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dim3SA_RBV")
    field(FLNK, "ADT:USER1:CAM:Dim4SA_RBV")
}

record(subArray, "ADT:USER1:CAM:Dim4SA_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "4")
    field(FLNK, "ADT:USER1:CAM:ArraySize4_RBV")
}

record(longin, "ADT:USER1:CAM:ArraySize4_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dim4SA_RBV")
    field(FLNK, "ADT:USER1:CAM:Dim5SA_RBV")
}

record(subArray, "ADT:USER1:CAM:Dim5SA_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "5")
    field(FLNK, "ADT:USER1:CAM:ArraySize5_RBV")
}

record(longin, "ADT:USER1:CAM:ArraySize5_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dim5SA_RBV")
    field(FLNK, "ADT:USER1:CAM:Dim6SA_RBV")
}

record(subArray, "ADT:USER1:CAM:Dim6SA_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "6")
    field(FLNK, "ADT:USER1:CAM:ArraySize6_RBV")
}

record(longin, "ADT:USER1:CAM:ArraySize6_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dim6SA_RBV")
    field(FLNK, "ADT:USER1:CAM:Dim7SA_RBV")
}

record(subArray, "ADT:USER1:CAM:Dim7SA_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "7")
    field(FLNK, "ADT:USER1:CAM:ArraySize7_RBV")
}

record(longin, "ADT:USER1:CAM:ArraySize7_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dim7SA_RBV")
    field(FLNK, "ADT:USER1:CAM:Dim8SA_RBV")
}

record(subArray, "ADT:USER1:CAM:Dim8SA_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "8")
    field(FLNK, "ADT:USER1:CAM:ArraySize8_RBV")
}

record(longin, "ADT:USER1:CAM:ArraySize8_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dim8SA_RBV")
    field(FLNK, "ADT:USER1:CAM:Dim9SA_RBV")
}

record(subArray, "ADT:USER1:CAM:Dim9SA_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "9")
    field(FLNK, "ADT:USER1:CAM:ArraySize9_RBV")
}

record(longin, "ADT:USER1:CAM:ArraySize9_RBV")
{
    field(INP,  "ADT:USER1:CAM:Dim9SA_RBV")
}


record(mbbi, "ADT:USER1:CAM:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:CAM:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:CAM:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:CAM:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:CAM:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records have information on the compression              # 
###################################################################
record(stringin, "ADT:USER1:CAM:Codec_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.CAM,0,1)CODEC")
   field(VAL,  "")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:CAM:CompressedSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)COMPRESSED_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "ADT:USER1:CAM:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Int64")
   field(SXVL, "6")
   field(SVST, "UInt64")
   field(SVVL, "7")
   field(EIST, "Float32")
   field(EIVL, "8")
   field(NIST, "Float64")
   field(NIVL, "9")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:CAM:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Int64")
   field(SXVL, "6")
   field(SVST, "UInt64")
   field(SVVL, "7")
   field(EIST, "Float32")
   field(EIVL, "8")
   field(NIST, "Float64")
   field(NIVL, "9")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "ADT:USER1:CAM:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:CAM:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "ADT:USER1:CAM:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "ADT:USER1:CAM:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.CAM,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:CAM:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:CAM:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "ADT:USER1:CAM:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.CAM,0,1)ARRAY_COUNTER")
}

record(longin, "ADT:USER1:CAM:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "ADT:USER1:CAM:ArrayRate_RBV")
{
    field(INPA, "ADT:USER1:CAM:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "ADT:USER1:CAM:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "ADT:USER1:CAM:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "ADT:USER1:CAM:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.CAM,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Enable")
    field(OSV,  "MINOR")
    field(VAL, "1")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:CAM:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Enable")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains macro definitions for the attributes      # 
###################################################################

record(waveform, "ADT:USER1:CAM:NDAttributesMacros")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.CAM,0,1)ND_ATTRIBUTES_MACROS")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  This record is the name of a file defining attributes          # 
###################################################################

record(waveform, "ADT:USER1:CAM:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.CAM,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  This record defines the status of reading attributes file      # 
###################################################################

record(mbbi, "ADT:USER1:CAM:NDAttributesStatus")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)ND_ATTRIBUTES_STATUS")
    field(ZRVL, "0")
    field(ZRST, "Attributes file OK")
    field(ZRSV, "NO_ALARM")
    field(ONVL, "1")
    field(ONST, "File not found")
    field(ONSV, "MINOR")
    field(TWVL, "2")
    field(TWST, "XML syntax error")
    field(TWSV, "MAJOR")
    field(THVL, "3")
    field(THST, "Macro substitution error")
    field(THSV, "MAJOR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "ADT:USER1:CAM:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "ADT:USER1:CAM:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "ADT:USER1:CAM:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "ADT:USER1:CAM:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "ADT:USER1:CAM:PoolFreeBuffers")
}

record(longin, "ADT:USER1:CAM:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "ADT:USER1:CAM:PoolUsedBuffers")
}

record(calc, "ADT:USER1:CAM:PoolUsedBuffers")
{
    field(INPA, "ADT:USER1:CAM:PoolAllocBuffers NPP MS")
    field(INPB, "ADT:USER1:CAM:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

record(bo, "ADT:USER1:CAM:EmptyFreeList")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)POOL_EMPTY_FREELIST")
}

record(longin, "ADT:USER1:CAM:NumQueuedArrays")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)NUM_QUEUED_ARRAYS")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:CAM:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)MAX_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:CAM:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)MAX_SIZE_Y")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the detector readout                     #
#  including binning, region start and size                       # 
###################################################################

record(longout, "ADT:USER1:CAM:BinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)BIN_X")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:BinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)BIN_X")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:BinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)BIN_Y")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:BinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)BIN_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)MIN_X")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)MIN_X")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)MIN_Y")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)MIN_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIZE_X")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIZE_Y")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(bo, "ADT:USER1:CAM:ReverseX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)REVERSE_X")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:CAM:ReverseX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)REVERSE_X")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "ADT:USER1:CAM:ReverseY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)REVERSE_Y")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:CAM:ReverseY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)REVERSE_Y")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control the acquisition time and                 #
#  period                                                         # 
###################################################################
record(ao, "ADT:USER1:CAM:AcquireTime")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)ACQ_TIME")
   field(PREC, "3")
   field(VAL,  "1.0")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:AcquireTime_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)ACQ_TIME")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:AcquirePeriod")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)ACQ_PERIOD")
   field(PREC, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:AcquirePeriod_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)ACQ_PERIOD")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(ai, "ADT:USER1:CAM:TimeRemaining_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)TIME_REMAINING")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the gain                                 # 
###################################################################
record(ao, "ADT:USER1:CAM:Gain")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)GAIN")
   field(VAL,  "1.0")
   field(PREC, "3")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:Gain_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)GAIN")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the frame type                           # 
###################################################################
record(mbbo, "ADT:USER1:CAM:FrameType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)FRAME_TYPE")
   field(ZRST, "Normal")
   field(ZRVL, "0")
   field(ONST, "Background")
   field(ONVL, "1")
   field(TWST, "FlatField")
   field(TWVL, "2")
   field(THST, "DblCorrelation")
   field(THVL, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:CAM:FrameType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)FRAME_TYPE")
   field(ZRST, "Normal")
   field(ZRVL, "0")
   field(ONST, "Background")
   field(ONVL, "1")
   field(TWST, "FlatField")
   field(TWVL, "2")
   field(THST, "DblCorrelation")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the acquisition mode                     # 
###################################################################
record(mbbo, "ADT:USER1:CAM:ImageMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)IMAGE_MODE")
   field(ZRST, "Single")
   field(ZRVL, "0")
   field(ONST, "Multiple")
   field(ONVL, "1")
   field(TWST, "Continuous")
   field(TWVL, "2")
   field(VAL,  "2")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:CAM:ImageMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)IMAGE_MODE")
   field(ZRST, "Single")
   field(ZRVL, "0")
   field(ONST, "Multiple")
   field(ONVL, "1")
   field(TWST, "Continuous")
   field(TWVL, "2")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the trigger mode                         # 
###################################################################
record(mbbo, "ADT:USER1:CAM:TriggerMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)TRIGGER_MODE")
   field(ZRST, "Internal")
   field(ZRVL, "0")
   field(ONST, "External")
   field(ONVL, "1")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:CAM:TriggerMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)TRIGGER_MODE")
   field(ZRST, "Internal")
   field(ZRVL, "0")
   field(ONST, "External")
   field(ONVL, "1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the number of exposures and              #
#  number of images                                               # 
###################################################################
record(longout, "ADT:USER1:CAM:NumExposures")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)NEXPOSURES")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:NumExposures_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)NEXPOSURES")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:CAM:NumExposuresCounter_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)NEXPOSURES_COUNTER")
   field(SCAN, "I/O Intr")
}
record(longout, "ADT:USER1:CAM:NumImages")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)NIMAGES")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:NumImages_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)NIMAGES")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:CAM:NumImagesCounter_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)NIMAGES_COUNTER")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are for the detector state                       # 
###################################################################

record(mbbi, "ADT:USER1:CAM:DetectorState_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)STATUS")
    field(ZRST, "Idle")
    field(ZRVL, "0")
    field(ZRSV, "NO_ALARM")
    field(ONST, "Acquire")
    field(ONVL, "1")
    field(ONSV, "NO_ALARM")
    field(TWST, "Readout")
    field(TWVL, "2")
    field(TWSV, "NO_ALARM")
    field(THST, "Correct")
    field(THVL, "3")
    field(THSV, "NO_ALARM")
    field(FRST, "Saving")
    field(FRVL, "4")
    field(FRSV, "NO_ALARM")
    field(FVST, "Aborting")
    field(FVVL, "5")
    field(FVSV, "MINOR")
    field(SXST, "Error")
    field(SXVL, "6")
    field(SXSV, "MAJOR")
    field(SVST, "Waiting")
    field(SVVL, "7")
    field(SVSV, "NO_ALARM")
    field(EIST, "Initializing")
    field(EIVL, "8")
    field(EISV, "NO_ALARM")
    field(NIST, "Disconnected")
    field(NIVL, "9")
    field(NISV, "INVALID")
    field(TEST, "Aborted")
    field(TEVL, "10")
    field(TESV, "MINOR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide status information                       # 
###################################################################

# Status message.
record(waveform, "ADT:USER1:CAM:StatusMessage_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.CAM,0,1)STATUS_MESSAGE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(waveform, "ADT:USER1:CAM:StringToServer_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.CAM,0,1)STRING_TO_SERVER")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(waveform, "ADT:USER1:CAM:StringFromServer_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.CAM,0,1)STRING_FROM_SERVER")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

################################################################@###
#  This record can be used to force a read of the detector status  # 
####################################################################
record(bo,"ADT:USER1:CAM:ReadStatus") {
    field(DTYP,"asynInt32")
    field(OUT, "@asyn(SIM.CAM,0,1)READ_STATUS")
    field(VAL, "1")
    field(SCAN,"Passive")
    info(autosaveFields, "SCAN")
}

###################################################################
#  These records control the shutter                              # 
###################################################################

record(mbbo, "ADT:USER1:CAM:ShutterMode")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.CAM,0,1)SHUTTER_MODE")
    field(ZRST, "None")
    field(ZRVL, "0")
    field(ONST, "EPICS PV")
    field(ONVL, "1")
    field(TWST, "Detector output")
    field(TWVL, "2")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:CAM:ShutterMode_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)SHUTTER_MODE")
    field(ZRST, "None")
    field(ZRVL, "0")
    field(ONST, "EPICS PV")
    field(ONVL, "1")
    field(TWST, "Camera output")
    field(TWVL, "2")
    field(SCAN, "I/O Intr")
}

record(bo, "ADT:USER1:CAM:ShutterControl")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.CAM,0,1)SHUTTER_CONTROL")
    field(ZNAM, "Close")
    field(ONAM, "Open")
    field(VAL,  "0")
}

record(bi, "ADT:USER1:CAM:ShutterControl_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)SHUTTER_CONTROL")
    field(ZNAM, "Close")
    field(ONAM, "Open")
    field(SCAN, "I/O Intr")
}

record(bi, "ADT:USER1:CAM:ShutterStatus_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)SHUTTER_STATUS")
    field(ZNAM, "Closed")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Open")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:ShutterOpenDelay")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SHUTTER_OPEN_DELAY")
   field(PREC, "3")
   field(VAL,  "0.0")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:ShutterOpenDelay_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SHUTTER_OPEN_DELAY")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:ShutterCloseDelay")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SHUTTER_CLOSE_DELAY")
   field(PREC, "3")
   field(VAL,  "0.0")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:ShutterCloseDelay_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SHUTTER_CLOSE_DELAY")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

# This record changes state when the driver opens/closes an EPICS shutter
record(bi, "ADT:USER1:CAM:ShutterControlEPICS")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.CAM,0,1)SHUTTER_CONTROL_EPICS")
    field(ZNAM, "Closed")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Open")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
    field(FLNK, "ADT:USER1:CAM:ShutterFanout.PROC")
}

record(fanout, "ADT:USER1:CAM:ShutterFanout")
{
    field(LNK1, "ADT:USER1:CAM:ShutterOpenEPICS.PROC PP MS")
    field(LNK2, "ADT:USER1:CAM:ShutterCloseEPICS.PROC PP MS")
}

record(calcout, "ADT:USER1:CAM:ShutterOpenEPICS")
{
    field(INPA, "ADT:USER1:CAM:ShutterControlEPICS.VAL NPP NMS")
    field(CALC, "A")
    field(OOPT, "Transition To Non-zero")
    field(DOPT, "Use OCAL")
    field(OCAL, "1")
    field(OUT,  "")
    info(autosaveFields, "OUT OCAL")
}

record(calcout, "ADT:USER1:CAM:ShutterCloseEPICS")
{
    field(INPA, "ADT:USER1:CAM:ShutterControlEPICS.VAL NPP NMS")
    field(CALC, "A")
    field(OOPT, "Transition To Zero")
    field(DOPT, "Use OCAL")
    field(OCAL, "0")
    field(OUT,  "")
    info(autosaveFields, "OUT OCAL")
}

record(mbbi, "ADT:USER1:CAM:ShutterStatusEPICS_RBV")
{
    field(DTYP, "Raw Soft Channel")
    field(INP,  "test CP MS")
    field(ZRVL, "0")
    field(ZRST, "Closed")
    field(ZRSV, "NO_ALARM")
    field(ONVL, "1")
    field(ONST, "Open")
    field(ONSV, "MINOR")
    info(autosaveFields, "INP ZRVL ONVL")
}

###################################################################
#  These records control the detector temperature                 # 
###################################################################
 
record(ao, "ADT:USER1:CAM:Temperature")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)TEMPERATURE")
   field(PREC, "1")
   field(EGU,  "C")
   field(VAL,  "25.0")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:Temperature_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)TEMPERATURE")
   field(PREC, "1")
   field(EGU,  "C")
   field(SCAN, "I/O Intr")
}

record(ai, "ADT:USER1:CAM:TemperatureActual")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)TEMPERATURE_ACTUAL")
   field(PREC, "1")
   field(EGU,  "C")
   field(SCAN, "I/O Intr")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"ADT:USER1:CAM:AsynIO")
{
    field(PORT, "SIM.CAM")
    field(TIB2,"1")
    info("ADType", "ADDriver")
}


# Redefine the color mode choices from ADBase.template to only have those that the simDetector
# driver supports.  Keep the same values (xxVL), but change the menu numbers.

record(mbbo, "ADT:USER1:CAM:ColorMode")
{
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "RGB1")
   field(ONVL, "2")
   field(TWST, "RGB2")
   field(TWVL, "3")
   field(THST, "RGB3")
   field(THVL, "4")
   field(FRST, "")
   field(FVST, "")
   field(SXST, "")
   field(SVST, "")
   field(EIST, "")
}

record(mbbi, "ADT:USER1:CAM:ColorMode_RBV")
{
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "RGB1")
   field(ONVL, "2")
   field(TWST, "RGB2")
   field(TWVL, "3")
   field(THST, "RGB3")
   field(THVL, "4")
   field(FRST, "")
   field(FVST, "")
   field(SXST, "")
   field(SVST, "")
   field(EIST, "")
}


# New records for simulation detector
record(ao, "ADT:USER1:CAM:GainX")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_GAIN_X")
   field(PREC, "2")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:GainX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_GAIN_X")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:GainY")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_GAIN_Y")
   field(PREC, "2")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:GainY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_GAIN_Y")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:GainRed")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_GAIN_RED")
   field(PREC, "2")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:GainRed_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_GAIN_RED")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:GainGreen")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_GAIN_GREEN")
   field(PREC, "2")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:GainGreen_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_GAIN_GREEN")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:GainBlue")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_GAIN_BLUE")
   field(PREC, "2")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:GainBlue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_GAIN_BLUE")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)RESET_IMAGE")
}

record(longin, "ADT:USER1:CAM:Reset_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)RESET_IMAGE")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:Offset")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_OFFSET")
   field(PREC, "1")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:Offset_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_OFFSET")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:Noise")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_NOISE")
   field(PREC, "1")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:Noise_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_NOISE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(mbbo, "ADT:USER1:CAM:SimMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_MODE")
   field(ZRST, "LinearRamp")
   field(ZRVL, "0")
   field(ONST, "Peaks")
   field(ONVL, "1")
   field(TWST, "Sine")
   field(TWVL, "2")
   field(THST, "Offset&Noise")
   field(THVL, "3")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:CAM:SimMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_MODE")
   field(ZRST, "LinearRamp")
   field(ZRVL, "0")
   field(ONST, "Peaks")
   field(ONVL, "1")
   field(TWST, "Sine")
   field(TWVL, "2")
   field(THST, "Offset&Noise")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

# Records for peak simulation mode
record(longout, "ADT:USER1:CAM:PeakStartX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_PEAK_START_X")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:PeakStartX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_PEAK_START_X")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:PeakStartY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_PEAK_START_Y")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:PeakStartY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_PEAK_START_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:PeakNumX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_PEAK_NUM_X")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:PeakNumX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_PEAK_NUM_X")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:PeakNumY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_PEAK_NUM_Y")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:PeakNumY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_PEAK_NUM_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:PeakStepX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_PEAK_STEP_X")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:PeakStepX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_PEAK_STEP_X")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:PeakStepY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_PEAK_STEP_Y")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:PeakStepY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_PEAK_STEP_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:PeakWidthX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_PEAK_WIDTH_X")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:PeakWidthX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_PEAK_WIDTH_X")
   field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:CAM:PeakWidthY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_PEAK_WIDTH_Y")
   info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:CAM:PeakWidthY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_PEAK_WIDTH_Y")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:PeakVariation")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_PEAK_HEIGHT_VARIATION")
   field(PREC, "1")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:PeakVariation_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_PEAK_HEIGHT_VARIATION")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

# Records for sine wave simulation mode
record(mbbo, "ADT:USER1:CAM:XSineOperation")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_XSINE_OPERATION")
   field(ZRST, "Add")
   field(ZRVL, "0")
   field(ONST, "Multiply")
   field(ONVL, "1")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:CAM:XSineOperation_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_XSINE_OPERATION")
   field(ZRST, "LinearRamp")
   field(ZRST, "Add")
   field(ZRVL, "0")
   field(ONST, "Multiply")
   field(ONVL, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:XSine1Amplitude")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_XSINE1_AMPLITUDE")
   field(PREC, "2")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:XSine1Amplitude_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_XSINE1_AMPLITUDE")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:XSine1Frequency")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_XSINE1_FREQUENCY")
   field(PREC, "2")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:XSine1Frequency_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_XSINE1_FREQUENCY")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:XSine1Phase")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_XSINE1_PHASE")
   field(PREC, "2")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:XSine1Phase_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_XSINE1_PHASE")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:XSine2Amplitude")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_XSINE2_AMPLITUDE")
   field(PREC, "2")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:XSine2Amplitude_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_XSINE2_AMPLITUDE")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:XSine2Frequency")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_XSINE2_FREQUENCY")
   field(PREC, "2")
   field(VAL,  "2")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:XSine2Frequency_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_XSINE2_FREQUENCY")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:XSine2Phase")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_XSINE2_PHASE")
   field(PREC, "2")
   field(VAL,  "90")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:XSine2Phase_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_XSINE2_PHASE")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(mbbo, "ADT:USER1:CAM:YSineOperation")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_YSINE_OPERATION")
   field(ZRST, "Add")
   field(ZRVL, "0")
   field(ONST, "Multiply")
   field(ONVL, "1")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:CAM:YSineOperation_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_YSINE_OPERATION")
   field(ZRST, "LinearRamp")
   field(ZRST, "Add")
   field(ZRVL, "0")
   field(ONST, "Multiply")
   field(ONVL, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:YSine1Amplitude")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_YSINE1_AMPLITUDE")
   field(PREC, "2")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:YSine1Amplitude_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_YSINE1_AMPLITUDE")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:YSine1Frequency")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_YSINE1_FREQUENCY")
   field(PREC, "2")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:YSine1Frequency_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_YSINE1_FREQUENCY")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:YSine1Phase")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_YSINE1_PHASE")
   field(PREC, "2")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:YSine1Phase_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_YSINE1_PHASE")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:YSine2Amplitude")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_YSINE2_AMPLITUDE")
   field(PREC, "2")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:YSine2Amplitude_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_YSINE2_AMPLITUDE")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:YSine2Frequency")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_YSINE2_FREQUENCY")
   field(PREC, "2")
   field(VAL,  "2")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:YSine2Frequency_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_YSINE2_FREQUENCY")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:CAM:YSine2Phase")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(SIM.CAM,0,1)SIM_YSINE2_PHASE")
   field(PREC, "2")
   field(VAL,  "90")
   info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:CAM:YSine2Phase_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.CAM,0,1)SIM_YSINE2_PHASE")
   field(PREC, "2")
   field(SCAN, "I/O Intr")
}

#=================================================================#
# Template file: NDFileTIFF.template
# Database for NDFileTIFF driver, which saves NDArray data 
# in the TIFF file format
# Mark Rivers
# May 10, 2009

#=================================================================#
# Template file: NDFile.template
# Database for NDFile driver, which saves files for NDArray data.
# Mark Rivers
# April 7, 2008

###################################################################
#  These records control file I/O                                 # 
###################################################################

# File path.
record(waveform, "ADT:USER1:TIFF1:FilePath")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.tiff,0,1)FILE_PATH")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

record(waveform, "ADT:USER1:TIFF1:FilePath_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.tiff,0,1)FILE_PATH")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(bi, "ADT:USER1:TIFF1:FilePathExists_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)FILE_PATH_EXISTS")
    field(ZNAM, "No")
    field(ZSV,  "MAJOR")
    field(ONAM, "Yes")
    field(OSV,  "NO_ALARM")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:TIFF1:CreateDirectory")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)CREATE_DIR")
    field(VAL,  "0" )
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:TIFF1:CreateDirectory_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)CREATE_DIR")
    field(VAL,  "")
    field(SCAN, "I/O Intr")
}

# Filename
record(waveform, "ADT:USER1:TIFF1:FileName")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.tiff,0,1)FILE_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

record(waveform, "ADT:USER1:TIFF1:FileName_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.tiff,0,1)FILE_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:TIFF1:FileNumber")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)FILE_NUMBER")
    field(VAL,  "1")
    info(asyn:READBACK, "1")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:TIFF1:FileNumber_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)FILE_NUMBER")
    field(SCAN, "I/O Intr")
}

# Autoincrement flag
record(bo, "ADT:USER1:TIFF1:AutoIncrement")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)AUTO_INCREMENT")
    field(VAL,  "1")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:TIFF1:AutoIncrement_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)AUTO_INCREMENT")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}

# File template
record(waveform, "ADT:USER1:TIFF1:FileTemplate")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.tiff,0,1)FILE_TEMPLATE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

record(waveform, "ADT:USER1:TIFF1:FileTemplate_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.tiff,0,1)FILE_TEMPLATE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

# Full filename, including path
record(waveform, "ADT:USER1:TIFF1:FullFileName_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.tiff,0,1)FULL_FILE_NAME")
    field(FTVL, "CHAR")
    field(NELM, "512")
    field(SCAN, "I/O Intr")
}

# Autosave flag
record(bo, "ADT:USER1:TIFF1:AutoSave")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)AUTO_SAVE")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:TIFF1:AutoSave_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)AUTO_SAVE")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}

# Write file
record(busy, "ADT:USER1:TIFF1:WriteFile")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)WRITE_FILE")
    field(ZNAM, "Done")
    field(ONAM, "Write")
}

record(bi, "ADT:USER1:TIFF1:WriteFile_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)WRITE_FILE")
    field(ZNAM, "Done")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Writing")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}


# Read file
record(busy, "ADT:USER1:TIFF1:ReadFile")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)READ_FILE")
    field(ZNAM, "Done")
    field(ONAM, "Read")
}

record(bi, "ADT:USER1:TIFF1:ReadFile_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)READ_FILE")
    field(ZNAM, "Done")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Reading")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

# File data format 
record(mbbo, "ADT:USER1:TIFF1:FileFormat")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)FILE_FORMAT")
    field(VAL,  "0")
    field(ZRST, "Undefined")
    field(ZRVL, "0")
    field(ONST, "Invalid")
    field(ONVL, "1")
    info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:TIFF1:FileFormat_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)FILE_FORMAT")
    field(ZRST, "netCDF")
    field(ZRVL, "0")
    field(ONST, "Undefined")
    field(ONVL, "1")
    field(SCAN, "I/O Intr")
}

# File save mode 
record(mbbo, "ADT:USER1:TIFF1:FileWriteMode")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)WRITE_MODE")
    field(VAL,  "0")
    field(ZRST, "Single")
    field(ZRVL, "0")
    field(ONST, "Capture")
    field(ONVL, "1")
    field(TWST, "Stream")
    field(TWVL, "2")
    info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:TIFF1:FileWriteMode_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)WRITE_MODE")
    field(ZRST, "Single")
    field(ZRVL, "0")
    field(ONST, "Capture")
    field(ONVL, "1")
    field(TWST, "Stream")
    field(TWVL, "2")
    field(SCAN, "I/O Intr")
}

# Capture data
record(busy, "ADT:USER1:TIFF1:Capture")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)CAPTURE")
    field(ZNAM, "Done")
    field(ONAM, "Capture")
}

record(bi, "ADT:USER1:TIFF1:Capture_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)CAPTURE")
    field(ZNAM, "Done")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Capturing")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:TIFF1:NumCapture")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)NUM_CAPTURE")
    field(VAL,  "1")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:TIFF1:NumCapture_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)NUM_CAPTURE")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:TIFF1:NumCaptured_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)NUM_CAPTURED")
    field(SCAN, "I/O Intr")
}

# Delete driver file flag
record(bo, "ADT:USER1:TIFF1:DeleteDriverFile")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)DELETE_DRIVER_FILE")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:TIFF1:DeleteDriverFile_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)DELETE_DRIVER_FILE")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}

record(bi, "ADT:USER1:TIFF1:WriteStatus")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)WRITE_STATUS")
    field(ZNAM, "Write OK")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Write error")
    field(OSV,  "MAJOR")
    field(SCAN, "I/O Intr")
}

record(waveform, "ADT:USER1:TIFF1:WriteMessage")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.tiff,0,1)WRITE_MESSAGE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(bo, "ADT:USER1:TIFF1:LazyOpen")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)FILE_LAZY_OPEN")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:TIFF1:LazyOpen_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)FILE_LAZY_OPEN")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:TIFF1:TempSuffix")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(SIM.tiff,0,1)FILE_TEMP_SUFFIX")
    field(VAL,  "")
}

record(stringin, "ADT:USER1:TIFF1:TempSuffix_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.tiff,0,1)FILE_TEMP_SUFFIX")
    field(VAL,  "")
    field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "ADT:USER1:TIFF1:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.tiff,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the version of the driver or plugin       #
###################################################################

record(stringin, "ADT:USER1:TIFF1:DriverVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.tiff,0,1)DRIVER_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "ADT:USER1:TIFF1:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.tiff,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records contain basic information about the detector     # 
###################################################################

record(stringin, "ADT:USER1:TIFF1:Manufacturer_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.tiff,0,1)MANUFACTURER")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:TIFF1:Model_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.tiff,0,1)MODEL")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:TIFF1:SerialNumber_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.tiff,0,1)SERIAL_NUMBER")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:TIFF1:SDKVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.tiff,0,1)SDK_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:TIFF1:FirmwareVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.tiff,0,1)FIRMWARE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control acquisition start and stop               #
###################################################################

record(bo, "ADT:USER1:TIFF1:Acquire") {
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(SIM.tiff,0,1)ACQUIRE")
   field(ZNAM, "Done")
   field(ONAM, "Acquire")
   field(VAL,  "0")
   field(FLNK, "ADT:USER1:TIFF1:SetAcquireBusy")
   info(asyn:READBACK, "1")
}

record(bi, "ADT:USER1:TIFF1:Acquire_RBV") {
   field(DTYP, "asynInt32")
   field(INP, "@asyn(SIM.tiff,0,1)ACQUIRE")
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:TIFF1:SetAcquireBusy")
{
    field(INPA, "ADT:USER1:TIFF1:Acquire NPP")
    field(CALC, "A")
    field(OOPT, "Transition To Non-zero")
    field(OUT,  "ADT:USER1:TIFF1:AcquireBusy PP")
}

record(busy, "ADT:USER1:TIFF1:AcquireBusy") {
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(VAL,  "0")
}

record(bi, "ADT:USER1:TIFF1:AcquireBusyCB") {
   field(DTYP, "asynInt32")
   field(INP, "@asyn(SIM.tiff,0,1)ACQUIRE_BUSY")
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:TIFF1:ClearAcquireBusy") {
    field(INPA, "ADT:USER1:TIFF1:AcquireBusyCB CP")
    field(CALC, "A")
    field(OOPT, "Transition To Zero")
    field(OUT,  "ADT:USER1:TIFF1:AcquireBusy PP")
}

record(bo, "ADT:USER1:TIFF1:WaitForPlugins") {
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(SIM.tiff,0,1)WAIT_FOR_PLUGINS")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(VAL,  "0")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longout, "ADT:USER1:TIFF1:NDimensions")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)ARRAY_NDIMENSIONS")
}

record(longin, "ADT:USER1:TIFF1:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform records
record(waveform, "ADT:USER1:TIFF1:Dimensions")
{
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(SIM.tiff,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "ADT:USER1:TIFF1:Dim0SA")
}

record(subArray, "ADT:USER1:TIFF1:Dim0SA")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize0")
}

record(longin, "ADT:USER1:TIFF1:ArraySize0")
{
    field(INP,  "ADT:USER1:TIFF1:Dim0SA")
    field(FLNK, "ADT:USER1:TIFF1:Dim1SA")
}

record(subArray, "ADT:USER1:TIFF1:Dim1SA")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize1")
}

record(longin, "ADT:USER1:TIFF1:ArraySize1")
{
    field(INP,  "ADT:USER1:TIFF1:Dim1SA")
    field(FLNK, "ADT:USER1:TIFF1:Dim2SA")
}

record(subArray, "ADT:USER1:TIFF1:Dim2SA")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize2")
}

record(longin, "ADT:USER1:TIFF1:ArraySize2")
{
    field(INP,  "ADT:USER1:TIFF1:Dim2SA")
    field(FLNK, "ADT:USER1:TIFF1:Dim3SA")
}

record(subArray, "ADT:USER1:TIFF1:Dim3SA")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "3")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize3")
}

record(longin, "ADT:USER1:TIFF1:ArraySize3")
{
    field(INP,  "ADT:USER1:TIFF1:Dim3SA")
    field(FLNK, "ADT:USER1:TIFF1:Dim4SA")
}

record(subArray, "ADT:USER1:TIFF1:Dim4SA")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "4")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize4")
}

record(longin, "ADT:USER1:TIFF1:ArraySize4")
{
    field(INP,  "ADT:USER1:TIFF1:Dim4SA")
    field(FLNK, "ADT:USER1:TIFF1:Dim5SA")
}

record(subArray, "ADT:USER1:TIFF1:Dim5SA")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "5")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize5")
}

record(longin, "ADT:USER1:TIFF1:ArraySize5")
{
    field(INP,  "ADT:USER1:TIFF1:Dim5SA")
    field(FLNK, "ADT:USER1:TIFF1:Dim6SA")
}

record(subArray, "ADT:USER1:TIFF1:Dim6SA")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "6")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize6")
}

record(longin, "ADT:USER1:TIFF1:ArraySize6")
{
    field(INP,  "ADT:USER1:TIFF1:Dim6SA")
    field(FLNK, "ADT:USER1:TIFF1:Dim7SA")
}

record(subArray, "ADT:USER1:TIFF1:Dim7SA")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "7")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize7")
}

record(longin, "ADT:USER1:TIFF1:ArraySize7")
{
    field(INP,  "ADT:USER1:TIFF1:Dim7SA")
    field(FLNK, "ADT:USER1:TIFF1:Dim8SA")
}

record(subArray, "ADT:USER1:TIFF1:Dim8SA")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "8")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize8")
}

record(longin, "ADT:USER1:TIFF1:ArraySize8")
{
    field(INP,  "ADT:USER1:TIFF1:Dim8SA")
    field(FLNK, "ADT:USER1:TIFF1:Dim9SA")
}

record(subArray, "ADT:USER1:TIFF1:Dim9SA")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "9")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize9")
}

record(longin, "ADT:USER1:TIFF1:ArraySize9")
{
    field(INP,  "ADT:USER1:TIFF1:Dim9SA")
}


record(waveform, "ADT:USER1:TIFF1:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(SIM.tiff,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "ADT:USER1:TIFF1:Dim0SA_RBV")
    field(SCAN, "I/O Intr")
}

record(subArray, "ADT:USER1:TIFF1:Dim0SA_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize0_RBV")
}

record(longin, "ADT:USER1:TIFF1:ArraySize0_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dim0SA_RBV")
    field(FLNK, "ADT:USER1:TIFF1:Dim1SA_RBV")
}

record(subArray, "ADT:USER1:TIFF1:Dim1SA_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize1_RBV")
}

record(longin, "ADT:USER1:TIFF1:ArraySize1_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dim1SA_RBV")
    field(FLNK, "ADT:USER1:TIFF1:Dim2SA_RBV")
}

record(subArray, "ADT:USER1:TIFF1:Dim2SA_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize2_RBV")
}

record(longin, "ADT:USER1:TIFF1:ArraySize2_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dim2SA_RBV")
    field(FLNK, "ADT:USER1:TIFF1:Dim3SA_RBV")
}

record(subArray, "ADT:USER1:TIFF1:Dim3SA_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "3")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize3_RBV")
}

record(longin, "ADT:USER1:TIFF1:ArraySize3_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dim3SA_RBV")
    field(FLNK, "ADT:USER1:TIFF1:Dim4SA_RBV")
}

record(subArray, "ADT:USER1:TIFF1:Dim4SA_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "4")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize4_RBV")
}

record(longin, "ADT:USER1:TIFF1:ArraySize4_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dim4SA_RBV")
    field(FLNK, "ADT:USER1:TIFF1:Dim5SA_RBV")
}

record(subArray, "ADT:USER1:TIFF1:Dim5SA_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "5")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize5_RBV")
}

record(longin, "ADT:USER1:TIFF1:ArraySize5_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dim5SA_RBV")
    field(FLNK, "ADT:USER1:TIFF1:Dim6SA_RBV")
}

record(subArray, "ADT:USER1:TIFF1:Dim6SA_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "6")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize6_RBV")
}

record(longin, "ADT:USER1:TIFF1:ArraySize6_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dim6SA_RBV")
    field(FLNK, "ADT:USER1:TIFF1:Dim7SA_RBV")
}

record(subArray, "ADT:USER1:TIFF1:Dim7SA_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "7")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize7_RBV")
}

record(longin, "ADT:USER1:TIFF1:ArraySize7_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dim7SA_RBV")
    field(FLNK, "ADT:USER1:TIFF1:Dim8SA_RBV")
}

record(subArray, "ADT:USER1:TIFF1:Dim8SA_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "8")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize8_RBV")
}

record(longin, "ADT:USER1:TIFF1:ArraySize8_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dim8SA_RBV")
    field(FLNK, "ADT:USER1:TIFF1:Dim9SA_RBV")
}

record(subArray, "ADT:USER1:TIFF1:Dim9SA_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "9")
    field(FLNK, "ADT:USER1:TIFF1:ArraySize9_RBV")
}

record(longin, "ADT:USER1:TIFF1:ArraySize9_RBV")
{
    field(INP,  "ADT:USER1:TIFF1:Dim9SA_RBV")
}


record(mbbi, "ADT:USER1:TIFF1:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.tiff,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:TIFF1:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.tiff,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:TIFF1:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.tiff,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:TIFF1:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.tiff,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:TIFF1:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.tiff,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records have information on the compression              # 
###################################################################
record(stringin, "ADT:USER1:TIFF1:Codec_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.tiff,0,1)CODEC")
   field(VAL,  "")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:TIFF1:CompressedSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.tiff,0,1)COMPRESSED_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "ADT:USER1:TIFF1:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.tiff,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Int64")
   field(SXVL, "6")
   field(SVST, "UInt64")
   field(SVVL, "7")
   field(EIST, "Float32")
   field(EIVL, "8")
   field(NIST, "Float64")
   field(NIVL, "9")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:TIFF1:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.tiff,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Int64")
   field(SXVL, "6")
   field(SVST, "UInt64")
   field(SVVL, "7")
   field(EIST, "Float32")
   field(EIVL, "8")
   field(NIST, "Float64")
   field(NIVL, "9")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "ADT:USER1:TIFF1:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.tiff,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:TIFF1:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.tiff,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "ADT:USER1:TIFF1:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "ADT:USER1:TIFF1:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.tiff,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:TIFF1:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:TIFF1:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "ADT:USER1:TIFF1:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)ARRAY_COUNTER")
}

record(longin, "ADT:USER1:TIFF1:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "ADT:USER1:TIFF1:ArrayRate_RBV")
{
    field(INPA, "ADT:USER1:TIFF1:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "ADT:USER1:TIFF1:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "ADT:USER1:TIFF1:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "ADT:USER1:TIFF1:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Enable")
    field(OSV,  "MINOR")
    field(VAL, "1")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:TIFF1:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Enable")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains macro definitions for the attributes      # 
###################################################################

record(waveform, "ADT:USER1:TIFF1:NDAttributesMacros")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.tiff,0,1)ND_ATTRIBUTES_MACROS")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  This record is the name of a file defining attributes          # 
###################################################################

record(waveform, "ADT:USER1:TIFF1:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.tiff,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  This record defines the status of reading attributes file      # 
###################################################################

record(mbbi, "ADT:USER1:TIFF1:NDAttributesStatus")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)ND_ATTRIBUTES_STATUS")
    field(ZRVL, "0")
    field(ZRST, "Attributes file OK")
    field(ZRSV, "NO_ALARM")
    field(ONVL, "1")
    field(ONST, "File not found")
    field(ONSV, "MINOR")
    field(TWVL, "2")
    field(TWST, "XML syntax error")
    field(TWSV, "MAJOR")
    field(THVL, "3")
    field(THST, "Macro substitution error")
    field(THSV, "MAJOR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "ADT:USER1:TIFF1:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.tiff,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "ADT:USER1:TIFF1:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.tiff,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "ADT:USER1:TIFF1:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "ADT:USER1:TIFF1:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.tiff,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "ADT:USER1:TIFF1:PoolFreeBuffers")
}

record(longin, "ADT:USER1:TIFF1:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.tiff,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "ADT:USER1:TIFF1:PoolUsedBuffers")
}

record(calc, "ADT:USER1:TIFF1:PoolUsedBuffers")
{
    field(INPA, "ADT:USER1:TIFF1:PoolAllocBuffers NPP MS")
    field(INPB, "ADT:USER1:TIFF1:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

record(bo, "ADT:USER1:TIFF1:EmptyFreeList")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.tiff,0,1)POOL_EMPTY_FREELIST")
}

record(longin, "ADT:USER1:TIFF1:NumQueuedArrays")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.tiff,0,1)NUM_QUEUED_ARRAYS")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "ADT:USER1:TIFF1:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.tiff,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "ADT:USER1:TIFF1:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(SIM.tiff,0,1)NDARRAY_PORT")
    field(VAL,  "SIM.CAM")
    info(autosaveFields, "VAL")
}

record(stringin, "ADT:USER1:TIFF1:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.tiff,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:TIFF1:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:TIFF1:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "ADT:USER1:TIFF1:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "1")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:TIFF1:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:TIFF1:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(SIM.tiff,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    field(DRVL, "0")
    info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:TIFF1:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.tiff,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:TIFF1:MaxArrayRate")
{
    field(DTYP, "Soft Channel")
    field(OUT,  "ADT:USER1:TIFF1:MaxArrayRate_COUT PP")
    field(EGU,  "Hz")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(calcout, "ADT:USER1:TIFF1:MaxArrayRate_COUT")
{
    field(INPA, "ADT:USER1:TIFF1:MaxArrayRate")
    field(CALC, "A=0?0:1.0/A")
    field(OUT,  "ADT:USER1:TIFF1:MinCallbackTime PP")
}

record(calc, "ADT:USER1:TIFF1:MaxArrayRate_RBV")
{
    field(INPA, "ADT:USER1:TIFF1:MinCallbackTime_RBV CP")
    field(CALC, "A=0?0:1.0/A")
    field(EGU,  "Hz")
    field(PREC, "3")
    field(SCAN, "Passive")
}

record(ao, "ADT:USER1:TIFF1:MaxByteRate")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(SIM.tiff,0,1)MAX_BYTE_RATE")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    field(DRVL, "0")
    info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:TIFF1:MaxByteRate_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.tiff,0,1)MAX_BYTE_RATE")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the last execution time of the plugin     #
###################################################################
record(ai, "ADT:USER1:TIFF1:ExecutionTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.tiff,0,1)EXECUTION_TIME")
    field(EGU,  "ms")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record requests that the plugin execute again with the    #
#  same NDArray                                                   #
###################################################################
record(bo, "ADT:USER1:TIFF1:ProcessPlugin")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)PROCESS_PLUGIN")
    field(VAL,  "1")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "ADT:USER1:TIFF1:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:TIFF1:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "ADT:USER1:TIFF1:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "ADT:USER1:TIFF1:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:TIFF1:QueueSize")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)QUEUE_SIZE")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:TIFF1:QueueSize_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)QUEUE_SIZE")
    field(FLNK, "ADT:USER1:TIFF1:QueueFreeLow")
    field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:TIFF1:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "ADT:USER1:TIFF1:QueueSize")
    field(OUT,  "ADT:USER1:TIFF1:QueueFree.LOW")
    field(FLNK, "ADT:USER1:TIFF1:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "ADT:USER1:TIFF1:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "ADT:USER1:TIFF1:QueueSize")
   field(OUT,  "ADT:USER1:TIFF1:QueueUse.HIGH")
   field(FLNK, "ADT:USER1:TIFF1:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "ADT:USER1:TIFF1:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "ADT:USER1:TIFF1:QueueSize")
   field(OUT,  "ADT:USER1:TIFF1:QueueUse.HIHI")
}

record(longin, "ADT:USER1:TIFF1:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "ADT:USER1:TIFF1:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "ADT:USER1:TIFF1:QueueSize")
    field(INPB, "ADT:USER1:TIFF1:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}

record(longout, "ADT:USER1:TIFF1:NumThreads")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)NUM_THREADS")
    field(VAL,  "1")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:TIFF1:NumThreads_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)NUM_THREADS")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:TIFF1:MaxThreads_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)MAX_THREADS")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control output array sorting                     #
###################################################################
record(mbbo, "ADT:USER1:TIFF1:SortMode") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)SORT_MODE")
    field(ZRVL, "0")
    field(ZRST, "Unsorted")
    field(ONVL, "1")
    field(ONST, "Sorted")
}

record(mbbi, "ADT:USER1:TIFF1:SortMode_RBV") {
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)SORT_MODE")
    field(ZRVL, "0")
    field(ZRST, "Unsorted")
    field(ONVL, "1")
    field(ONST, "Sorted")
    field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:TIFF1:SortTime") {
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(SIM.tiff,0,1)SORT_TIME")
    field(PREC, "3")
    field(VAL, "0.1")
}

record(ai, "ADT:USER1:TIFF1:SortTime_RBV") {
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.tiff,0,1)SORT_TIME")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:TIFF1:SortSize")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)SORT_SIZE")
    field(VAL,  "20")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:TIFF1:SortSize_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)SORT_SIZE")
    field(FLNK, "ADT:USER1:TIFF1:SortFreeLow")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:TIFF1:SortFree") {
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)SORT_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:TIFF1:SortFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "ADT:USER1:TIFF1:SortSize")
    field(OUT,  "ADT:USER1:TIFF1:SortFree.LOW")
}

record(longout, "ADT:USER1:TIFF1:DroppedOutputArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)DROPPED_OUTPUT_ARRAYS")
    field(VAL,  "0")
}

record(longin, "ADT:USER1:TIFF1:DroppedOutputArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)DROPPED_OUTPUT_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:TIFF1:DisorderedArrays")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.tiff,0,1)DISORDERED_ARRAYS")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:TIFF1:DisorderedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.tiff,0,1)DISORDERED_ARRAYS")
    field(SCAN, "I/O Intr")
}



###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"ADT:USER1:TIFF1:AsynIO")
{
    field(PORT, "SIM.tiff")
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


# We replace some fields in records defined in NDFile.template
# File data format 
record(mbbo, "ADT:USER1:TIFF1:FileFormat")
{
    field(ZRST, "TIFF")
    field(ZRVL, "0")
    field(ONST, "Invalid")
    field(ONVL, "1")
}

record(mbbi, "ADT:USER1:TIFF1:FileFormat_RBV")
{
    field(ZRST, "TIFF")
    field(ZRVL, "0")
    field(ONST, "Undefined")
    field(ONVL, "1")
}

#=================================================================#
# Template file: NDFileHDF5.template
# Database for NDFileHDF5 driver, which saves files for NDArray data.

# Macros:
# % macro, P, Device Prefix
# % macro, R, Device Suffix
# % macro, PORT, Asyn Port name

# This associates the template with an edm screen
# % gui, SIM.hdf, edmtab, NDFileHDF5.edl, P=ADT:USER1,R=:HDF1:

#=================================================================#
# Template file: NDFile.template
# Database for NDFile driver, which saves files for NDArray data.
# Mark Rivers
# April 7, 2008

###################################################################
#  These records control file I/O                                 # 
###################################################################

# File path.
record(waveform, "ADT:USER1:HDF1:FilePath")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.hdf,0,1)FILE_PATH")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

record(waveform, "ADT:USER1:HDF1:FilePath_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.hdf,0,1)FILE_PATH")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(bi, "ADT:USER1:HDF1:FilePathExists_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)FILE_PATH_EXISTS")
    field(ZNAM, "No")
    field(ZSV,  "MAJOR")
    field(ONAM, "Yes")
    field(OSV,  "NO_ALARM")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:CreateDirectory")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)CREATE_DIR")
    field(VAL,  "0" )
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:CreateDirectory_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)CREATE_DIR")
    field(VAL,  "")
    field(SCAN, "I/O Intr")
}

# Filename
record(waveform, "ADT:USER1:HDF1:FileName")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.hdf,0,1)FILE_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

record(waveform, "ADT:USER1:HDF1:FileName_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.hdf,0,1)FILE_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:FileNumber")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)FILE_NUMBER")
    field(VAL,  "1")
    info(asyn:READBACK, "1")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:FileNumber_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)FILE_NUMBER")
    field(SCAN, "I/O Intr")
}

# Autoincrement flag
record(bo, "ADT:USER1:HDF1:AutoIncrement")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)AUTO_INCREMENT")
    field(VAL,  "1")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:HDF1:AutoIncrement_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)AUTO_INCREMENT")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}

# File template
record(waveform, "ADT:USER1:HDF1:FileTemplate")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.hdf,0,1)FILE_TEMPLATE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

record(waveform, "ADT:USER1:HDF1:FileTemplate_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.hdf,0,1)FILE_TEMPLATE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

# Full filename, including path
record(waveform, "ADT:USER1:HDF1:FullFileName_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.hdf,0,1)FULL_FILE_NAME")
    field(FTVL, "CHAR")
    field(NELM, "512")
    field(SCAN, "I/O Intr")
}

# Autosave flag
record(bo, "ADT:USER1:HDF1:AutoSave")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)AUTO_SAVE")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:HDF1:AutoSave_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)AUTO_SAVE")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}

# Write file
record(busy, "ADT:USER1:HDF1:WriteFile")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)WRITE_FILE")
    field(ZNAM, "Done")
    field(ONAM, "Write")
}

record(bi, "ADT:USER1:HDF1:WriteFile_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)WRITE_FILE")
    field(ZNAM, "Done")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Writing")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}


# Read file
record(busy, "ADT:USER1:HDF1:ReadFile")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)READ_FILE")
    field(ZNAM, "Done")
    field(ONAM, "Read")
}

record(bi, "ADT:USER1:HDF1:ReadFile_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)READ_FILE")
    field(ZNAM, "Done")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Reading")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

# File data format 
record(mbbo, "ADT:USER1:HDF1:FileFormat")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)FILE_FORMAT")
    field(VAL,  "0")
    field(ZRST, "Undefined")
    field(ZRVL, "0")
    field(ONST, "Invalid")
    field(ONVL, "1")
    info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:HDF1:FileFormat_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)FILE_FORMAT")
    field(ZRST, "netCDF")
    field(ZRVL, "0")
    field(ONST, "Undefined")
    field(ONVL, "1")
    field(SCAN, "I/O Intr")
}

# File save mode 
record(mbbo, "ADT:USER1:HDF1:FileWriteMode")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)WRITE_MODE")
    field(VAL,  "0")
    field(ZRST, "Single")
    field(ZRVL, "0")
    field(ONST, "Capture")
    field(ONVL, "1")
    field(TWST, "Stream")
    field(TWVL, "2")
    info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:HDF1:FileWriteMode_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)WRITE_MODE")
    field(ZRST, "Single")
    field(ZRVL, "0")
    field(ONST, "Capture")
    field(ONVL, "1")
    field(TWST, "Stream")
    field(TWVL, "2")
    field(SCAN, "I/O Intr")
}

# Capture data
record(busy, "ADT:USER1:HDF1:Capture")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)CAPTURE")
    field(ZNAM, "Done")
    field(ONAM, "Capture")
}

record(bi, "ADT:USER1:HDF1:Capture_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)CAPTURE")
    field(ZNAM, "Done")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Capturing")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:NumCapture")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)NUM_CAPTURE")
    field(VAL,  "1")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:NumCapture_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)NUM_CAPTURE")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:HDF1:NumCaptured_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)NUM_CAPTURED")
    field(SCAN, "I/O Intr")
}

# Delete driver file flag
record(bo, "ADT:USER1:HDF1:DeleteDriverFile")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)DELETE_DRIVER_FILE")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:HDF1:DeleteDriverFile_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)DELETE_DRIVER_FILE")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}

record(bi, "ADT:USER1:HDF1:WriteStatus")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)WRITE_STATUS")
    field(ZNAM, "Write OK")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Write error")
    field(OSV,  "MAJOR")
    field(SCAN, "I/O Intr")
}

record(waveform, "ADT:USER1:HDF1:WriteMessage")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.hdf,0,1)WRITE_MESSAGE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(bo, "ADT:USER1:HDF1:LazyOpen")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)FILE_LAZY_OPEN")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:HDF1:LazyOpen_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)FILE_LAZY_OPEN")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:TempSuffix")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(SIM.hdf,0,1)FILE_TEMP_SUFFIX")
    field(VAL,  "")
}

record(stringin, "ADT:USER1:HDF1:TempSuffix_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.hdf,0,1)FILE_TEMP_SUFFIX")
    field(VAL,  "")
    field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "ADT:USER1:HDF1:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.hdf,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the version of the driver or plugin       #
###################################################################

record(stringin, "ADT:USER1:HDF1:DriverVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.hdf,0,1)DRIVER_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "ADT:USER1:HDF1:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.hdf,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records contain basic information about the detector     # 
###################################################################

record(stringin, "ADT:USER1:HDF1:Manufacturer_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.hdf,0,1)MANUFACTURER")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:Model_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.hdf,0,1)MODEL")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:SerialNumber_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.hdf,0,1)SERIAL_NUMBER")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:SDKVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.hdf,0,1)SDK_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:FirmwareVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.hdf,0,1)FIRMWARE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control acquisition start and stop               #
###################################################################

record(bo, "ADT:USER1:HDF1:Acquire") {
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(SIM.hdf,0,1)ACQUIRE")
   field(ZNAM, "Done")
   field(ONAM, "Acquire")
   field(VAL,  "0")
   field(FLNK, "ADT:USER1:HDF1:SetAcquireBusy")
   info(asyn:READBACK, "1")
}

record(bi, "ADT:USER1:HDF1:Acquire_RBV") {
   field(DTYP, "asynInt32")
   field(INP, "@asyn(SIM.hdf,0,1)ACQUIRE")
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:HDF1:SetAcquireBusy")
{
    field(INPA, "ADT:USER1:HDF1:Acquire NPP")
    field(CALC, "A")
    field(OOPT, "Transition To Non-zero")
    field(OUT,  "ADT:USER1:HDF1:AcquireBusy PP")
}

record(busy, "ADT:USER1:HDF1:AcquireBusy") {
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(VAL,  "0")
}

record(bi, "ADT:USER1:HDF1:AcquireBusyCB") {
   field(DTYP, "asynInt32")
   field(INP, "@asyn(SIM.hdf,0,1)ACQUIRE_BUSY")
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:HDF1:ClearAcquireBusy") {
    field(INPA, "ADT:USER1:HDF1:AcquireBusyCB CP")
    field(CALC, "A")
    field(OOPT, "Transition To Zero")
    field(OUT,  "ADT:USER1:HDF1:AcquireBusy PP")
}

record(bo, "ADT:USER1:HDF1:WaitForPlugins") {
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(SIM.hdf,0,1)WAIT_FOR_PLUGINS")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(VAL,  "0")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longout, "ADT:USER1:HDF1:NDimensions")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)ARRAY_NDIMENSIONS")
}

record(longin, "ADT:USER1:HDF1:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform records
record(waveform, "ADT:USER1:HDF1:Dimensions")
{
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(SIM.hdf,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "ADT:USER1:HDF1:Dim0SA")
}

record(subArray, "ADT:USER1:HDF1:Dim0SA")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "ADT:USER1:HDF1:ArraySize0")
}

record(longin, "ADT:USER1:HDF1:ArraySize0")
{
    field(INP,  "ADT:USER1:HDF1:Dim0SA")
    field(FLNK, "ADT:USER1:HDF1:Dim1SA")
}

record(subArray, "ADT:USER1:HDF1:Dim1SA")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "ADT:USER1:HDF1:ArraySize1")
}

record(longin, "ADT:USER1:HDF1:ArraySize1")
{
    field(INP,  "ADT:USER1:HDF1:Dim1SA")
    field(FLNK, "ADT:USER1:HDF1:Dim2SA")
}

record(subArray, "ADT:USER1:HDF1:Dim2SA")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "ADT:USER1:HDF1:ArraySize2")
}

record(longin, "ADT:USER1:HDF1:ArraySize2")
{
    field(INP,  "ADT:USER1:HDF1:Dim2SA")
    field(FLNK, "ADT:USER1:HDF1:Dim3SA")
}

record(subArray, "ADT:USER1:HDF1:Dim3SA")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "3")
    field(FLNK, "ADT:USER1:HDF1:ArraySize3")
}

record(longin, "ADT:USER1:HDF1:ArraySize3")
{
    field(INP,  "ADT:USER1:HDF1:Dim3SA")
    field(FLNK, "ADT:USER1:HDF1:Dim4SA")
}

record(subArray, "ADT:USER1:HDF1:Dim4SA")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "4")
    field(FLNK, "ADT:USER1:HDF1:ArraySize4")
}

record(longin, "ADT:USER1:HDF1:ArraySize4")
{
    field(INP,  "ADT:USER1:HDF1:Dim4SA")
    field(FLNK, "ADT:USER1:HDF1:Dim5SA")
}

record(subArray, "ADT:USER1:HDF1:Dim5SA")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "5")
    field(FLNK, "ADT:USER1:HDF1:ArraySize5")
}

record(longin, "ADT:USER1:HDF1:ArraySize5")
{
    field(INP,  "ADT:USER1:HDF1:Dim5SA")
    field(FLNK, "ADT:USER1:HDF1:Dim6SA")
}

record(subArray, "ADT:USER1:HDF1:Dim6SA")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "6")
    field(FLNK, "ADT:USER1:HDF1:ArraySize6")
}

record(longin, "ADT:USER1:HDF1:ArraySize6")
{
    field(INP,  "ADT:USER1:HDF1:Dim6SA")
    field(FLNK, "ADT:USER1:HDF1:Dim7SA")
}

record(subArray, "ADT:USER1:HDF1:Dim7SA")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "7")
    field(FLNK, "ADT:USER1:HDF1:ArraySize7")
}

record(longin, "ADT:USER1:HDF1:ArraySize7")
{
    field(INP,  "ADT:USER1:HDF1:Dim7SA")
    field(FLNK, "ADT:USER1:HDF1:Dim8SA")
}

record(subArray, "ADT:USER1:HDF1:Dim8SA")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "8")
    field(FLNK, "ADT:USER1:HDF1:ArraySize8")
}

record(longin, "ADT:USER1:HDF1:ArraySize8")
{
    field(INP,  "ADT:USER1:HDF1:Dim8SA")
    field(FLNK, "ADT:USER1:HDF1:Dim9SA")
}

record(subArray, "ADT:USER1:HDF1:Dim9SA")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "9")
    field(FLNK, "ADT:USER1:HDF1:ArraySize9")
}

record(longin, "ADT:USER1:HDF1:ArraySize9")
{
    field(INP,  "ADT:USER1:HDF1:Dim9SA")
}


record(waveform, "ADT:USER1:HDF1:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(SIM.hdf,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "ADT:USER1:HDF1:Dim0SA_RBV")
    field(SCAN, "I/O Intr")
}

record(subArray, "ADT:USER1:HDF1:Dim0SA_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "ADT:USER1:HDF1:ArraySize0_RBV")
}

record(longin, "ADT:USER1:HDF1:ArraySize0_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dim0SA_RBV")
    field(FLNK, "ADT:USER1:HDF1:Dim1SA_RBV")
}

record(subArray, "ADT:USER1:HDF1:Dim1SA_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "ADT:USER1:HDF1:ArraySize1_RBV")
}

record(longin, "ADT:USER1:HDF1:ArraySize1_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dim1SA_RBV")
    field(FLNK, "ADT:USER1:HDF1:Dim2SA_RBV")
}

record(subArray, "ADT:USER1:HDF1:Dim2SA_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "ADT:USER1:HDF1:ArraySize2_RBV")
}

record(longin, "ADT:USER1:HDF1:ArraySize2_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dim2SA_RBV")
    field(FLNK, "ADT:USER1:HDF1:Dim3SA_RBV")
}

record(subArray, "ADT:USER1:HDF1:Dim3SA_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "3")
    field(FLNK, "ADT:USER1:HDF1:ArraySize3_RBV")
}

record(longin, "ADT:USER1:HDF1:ArraySize3_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dim3SA_RBV")
    field(FLNK, "ADT:USER1:HDF1:Dim4SA_RBV")
}

record(subArray, "ADT:USER1:HDF1:Dim4SA_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "4")
    field(FLNK, "ADT:USER1:HDF1:ArraySize4_RBV")
}

record(longin, "ADT:USER1:HDF1:ArraySize4_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dim4SA_RBV")
    field(FLNK, "ADT:USER1:HDF1:Dim5SA_RBV")
}

record(subArray, "ADT:USER1:HDF1:Dim5SA_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "5")
    field(FLNK, "ADT:USER1:HDF1:ArraySize5_RBV")
}

record(longin, "ADT:USER1:HDF1:ArraySize5_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dim5SA_RBV")
    field(FLNK, "ADT:USER1:HDF1:Dim6SA_RBV")
}

record(subArray, "ADT:USER1:HDF1:Dim6SA_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "6")
    field(FLNK, "ADT:USER1:HDF1:ArraySize6_RBV")
}

record(longin, "ADT:USER1:HDF1:ArraySize6_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dim6SA_RBV")
    field(FLNK, "ADT:USER1:HDF1:Dim7SA_RBV")
}

record(subArray, "ADT:USER1:HDF1:Dim7SA_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "7")
    field(FLNK, "ADT:USER1:HDF1:ArraySize7_RBV")
}

record(longin, "ADT:USER1:HDF1:ArraySize7_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dim7SA_RBV")
    field(FLNK, "ADT:USER1:HDF1:Dim8SA_RBV")
}

record(subArray, "ADT:USER1:HDF1:Dim8SA_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "8")
    field(FLNK, "ADT:USER1:HDF1:ArraySize8_RBV")
}

record(longin, "ADT:USER1:HDF1:ArraySize8_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dim8SA_RBV")
    field(FLNK, "ADT:USER1:HDF1:Dim9SA_RBV")
}

record(subArray, "ADT:USER1:HDF1:Dim9SA_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "9")
    field(FLNK, "ADT:USER1:HDF1:ArraySize9_RBV")
}

record(longin, "ADT:USER1:HDF1:ArraySize9_RBV")
{
    field(INP,  "ADT:USER1:HDF1:Dim9SA_RBV")
}


record(mbbi, "ADT:USER1:HDF1:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.hdf,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:HDF1:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.hdf,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:HDF1:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.hdf,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:HDF1:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.hdf,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:HDF1:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.hdf,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records have information on the compression              # 
###################################################################
record(stringin, "ADT:USER1:HDF1:Codec_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.hdf,0,1)CODEC")
   field(VAL,  "")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:HDF1:CompressedSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.hdf,0,1)COMPRESSED_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "ADT:USER1:HDF1:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.hdf,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Int64")
   field(SXVL, "6")
   field(SVST, "UInt64")
   field(SVVL, "7")
   field(EIST, "Float32")
   field(EIVL, "8")
   field(NIST, "Float64")
   field(NIVL, "9")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:HDF1:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.hdf,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Int64")
   field(SXVL, "6")
   field(SVST, "UInt64")
   field(SVVL, "7")
   field(EIST, "Float32")
   field(EIVL, "8")
   field(NIST, "Float64")
   field(NIVL, "9")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "ADT:USER1:HDF1:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.hdf,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:HDF1:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.hdf,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "ADT:USER1:HDF1:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "ADT:USER1:HDF1:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.hdf,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:HDF1:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:HDF1:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "ADT:USER1:HDF1:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)ARRAY_COUNTER")
}

record(longin, "ADT:USER1:HDF1:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "ADT:USER1:HDF1:ArrayRate_RBV")
{
    field(INPA, "ADT:USER1:HDF1:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "ADT:USER1:HDF1:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "ADT:USER1:HDF1:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "ADT:USER1:HDF1:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Enable")
    field(OSV,  "MINOR")
    field(VAL, "1")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:HDF1:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Enable")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains macro definitions for the attributes      # 
###################################################################

record(waveform, "ADT:USER1:HDF1:NDAttributesMacros")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.hdf,0,1)ND_ATTRIBUTES_MACROS")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  This record is the name of a file defining attributes          # 
###################################################################

record(waveform, "ADT:USER1:HDF1:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.hdf,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  This record defines the status of reading attributes file      # 
###################################################################

record(mbbi, "ADT:USER1:HDF1:NDAttributesStatus")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)ND_ATTRIBUTES_STATUS")
    field(ZRVL, "0")
    field(ZRST, "Attributes file OK")
    field(ZRSV, "NO_ALARM")
    field(ONVL, "1")
    field(ONST, "File not found")
    field(ONSV, "MINOR")
    field(TWVL, "2")
    field(TWST, "XML syntax error")
    field(TWSV, "MAJOR")
    field(THVL, "3")
    field(THST, "Macro substitution error")
    field(THSV, "MAJOR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "ADT:USER1:HDF1:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.hdf,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "ADT:USER1:HDF1:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.hdf,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "ADT:USER1:HDF1:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "ADT:USER1:HDF1:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.hdf,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "ADT:USER1:HDF1:PoolFreeBuffers")
}

record(longin, "ADT:USER1:HDF1:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.hdf,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "ADT:USER1:HDF1:PoolUsedBuffers")
}

record(calc, "ADT:USER1:HDF1:PoolUsedBuffers")
{
    field(INPA, "ADT:USER1:HDF1:PoolAllocBuffers NPP MS")
    field(INPB, "ADT:USER1:HDF1:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

record(bo, "ADT:USER1:HDF1:EmptyFreeList")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.hdf,0,1)POOL_EMPTY_FREELIST")
}

record(longin, "ADT:USER1:HDF1:NumQueuedArrays")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.hdf,0,1)NUM_QUEUED_ARRAYS")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "ADT:USER1:HDF1:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.hdf,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "ADT:USER1:HDF1:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(SIM.hdf,0,1)NDARRAY_PORT")
    field(VAL,  "SIM.CAM")
    info(autosaveFields, "VAL")
}

record(stringin, "ADT:USER1:HDF1:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.hdf,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "ADT:USER1:HDF1:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "1")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:HDF1:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:HDF1:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(SIM.hdf,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    field(DRVL, "0")
    info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:HDF1:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.hdf,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:HDF1:MaxArrayRate")
{
    field(DTYP, "Soft Channel")
    field(OUT,  "ADT:USER1:HDF1:MaxArrayRate_COUT PP")
    field(EGU,  "Hz")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(calcout, "ADT:USER1:HDF1:MaxArrayRate_COUT")
{
    field(INPA, "ADT:USER1:HDF1:MaxArrayRate")
    field(CALC, "A=0?0:1.0/A")
    field(OUT,  "ADT:USER1:HDF1:MinCallbackTime PP")
}

record(calc, "ADT:USER1:HDF1:MaxArrayRate_RBV")
{
    field(INPA, "ADT:USER1:HDF1:MinCallbackTime_RBV CP")
    field(CALC, "A=0?0:1.0/A")
    field(EGU,  "Hz")
    field(PREC, "3")
    field(SCAN, "Passive")
}

record(ao, "ADT:USER1:HDF1:MaxByteRate")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(SIM.hdf,0,1)MAX_BYTE_RATE")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    field(DRVL, "0")
    info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:HDF1:MaxByteRate_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.hdf,0,1)MAX_BYTE_RATE")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the last execution time of the plugin     #
###################################################################
record(ai, "ADT:USER1:HDF1:ExecutionTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.hdf,0,1)EXECUTION_TIME")
    field(EGU,  "ms")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record requests that the plugin execute again with the    #
#  same NDArray                                                   #
###################################################################
record(bo, "ADT:USER1:HDF1:ProcessPlugin")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)PROCESS_PLUGIN")
    field(VAL,  "1")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "ADT:USER1:HDF1:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:HDF1:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "ADT:USER1:HDF1:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "ADT:USER1:HDF1:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:QueueSize")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)QUEUE_SIZE")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:HDF1:QueueSize_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)QUEUE_SIZE")
    field(FLNK, "ADT:USER1:HDF1:QueueFreeLow")
    field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:HDF1:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "ADT:USER1:HDF1:QueueSize")
    field(OUT,  "ADT:USER1:HDF1:QueueFree.LOW")
    field(FLNK, "ADT:USER1:HDF1:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "ADT:USER1:HDF1:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "ADT:USER1:HDF1:QueueSize")
   field(OUT,  "ADT:USER1:HDF1:QueueUse.HIGH")
   field(FLNK, "ADT:USER1:HDF1:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "ADT:USER1:HDF1:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "ADT:USER1:HDF1:QueueSize")
   field(OUT,  "ADT:USER1:HDF1:QueueUse.HIHI")
}

record(longin, "ADT:USER1:HDF1:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "ADT:USER1:HDF1:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "ADT:USER1:HDF1:QueueSize")
    field(INPB, "ADT:USER1:HDF1:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}

record(longout, "ADT:USER1:HDF1:NumThreads")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)NUM_THREADS")
    field(VAL,  "1")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:HDF1:NumThreads_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)NUM_THREADS")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:HDF1:MaxThreads_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)MAX_THREADS")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control output array sorting                     #
###################################################################
record(mbbo, "ADT:USER1:HDF1:SortMode") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)SORT_MODE")
    field(ZRVL, "0")
    field(ZRST, "Unsorted")
    field(ONVL, "1")
    field(ONST, "Sorted")
}

record(mbbi, "ADT:USER1:HDF1:SortMode_RBV") {
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)SORT_MODE")
    field(ZRVL, "0")
    field(ZRST, "Unsorted")
    field(ONVL, "1")
    field(ONST, "Sorted")
    field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:HDF1:SortTime") {
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(SIM.hdf,0,1)SORT_TIME")
    field(PREC, "3")
    field(VAL, "0.1")
}

record(ai, "ADT:USER1:HDF1:SortTime_RBV") {
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.hdf,0,1)SORT_TIME")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:SortSize")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)SORT_SIZE")
    field(VAL,  "20")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:HDF1:SortSize_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)SORT_SIZE")
    field(FLNK, "ADT:USER1:HDF1:SortFreeLow")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:HDF1:SortFree") {
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)SORT_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:HDF1:SortFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "ADT:USER1:HDF1:SortSize")
    field(OUT,  "ADT:USER1:HDF1:SortFree.LOW")
}

record(longout, "ADT:USER1:HDF1:DroppedOutputArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)DROPPED_OUTPUT_ARRAYS")
    field(VAL,  "0")
}

record(longin, "ADT:USER1:HDF1:DroppedOutputArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)DROPPED_OUTPUT_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:DisorderedArrays")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)DISORDERED_ARRAYS")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:HDF1:DisorderedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)DISORDERED_ARRAYS")
    field(SCAN, "I/O Intr")
}



###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"ADT:USER1:HDF1:AsynIO")
{
    field(PORT, "SIM.hdf")
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


# Flush data to file
record(busy, "ADT:USER1:HDF1:FlushNow")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.hdf,0,1)HDF5_SWMRFlushNow")
    field(ZNAM, "Done")
    field(ONAM, "Flush")
}

# We replace some fields in records defined in NDFile.template
# File data format 
record(mbbo, "ADT:USER1:HDF1:FileFormat")
{
    field(ZRST, "HDF5")
    field(ZRVL, "0")
    field(ONST, "Invalid")
    field(ONVL, "1")
}

record(mbbi, "ADT:USER1:HDF1:FileFormat_RBV")
{
    field(ZRST, "HDF5")
    field(ZRVL, "0")
    field(ONST, "Undefined")
    field(ONVL, "1")
}

record(bo, "ADT:USER1:HDF1:ChunkSizeAuto")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_chunkSizeAuto")
    field(PINI, "YES")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "1")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:HDF1:ChunkSizeAuto_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_chunkSizeAuto")
    field(SCAN, "I/O Intr")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

record(longout, "ADT:USER1:HDF1:NumRowChunks")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_nRowChunks")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:NumRowChunks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_nRowChunks")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:NumColChunks")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_nColChunks")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:NumColChunks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_nColChunks")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ChunkSize2")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_chunkSize2")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ChunkSize2_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_chunkSize2")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ChunkSize3")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_chunkSize3")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ChunkSize3_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_chunkSize3")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ChunkSize4")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_chunkSize4")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ChunkSize4_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_chunkSize4")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ChunkSize5")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_chunkSize5")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ChunkSize5_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_chunkSize5")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ChunkSize6")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_chunkSize6")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ChunkSize6_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_chunkSize6")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ChunkSize7")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_chunkSize7")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ChunkSize7_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_chunkSize7")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ChunkSize8")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_chunkSize8")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ChunkSize8_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_chunkSize8")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ChunkSize9")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_chunkSize9")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ChunkSize9_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_chunkSize9")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:NumFramesChunks")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_nFramesChunks")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:NumFramesChunks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_nFramesChunks")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:NDAttributeChunk")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_NDAttributeChunk")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:NDAttributeChunk_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_NDAttributeChunk")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:BoundaryAlign")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_chunkBoundaryAlign")
    field(PINI, "YES")
    field(VAL, "0")
    field(EGU, "bytes")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:BoundaryAlign_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_chunkBoundaryAlign")
    field(SCAN, "I/O Intr")
    field(EGU, "bytes")
}

record(longout, "ADT:USER1:HDF1:BoundaryThreshold")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_chunkBoundaryThreshold")
    field(PINI, "YES")
    field(VAL, "1")
    field(EGU, "bytes")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:BoundaryThreshold_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_chunkBoundaryThreshold")
    field(SCAN, "I/O Intr")
    field(EGU, "bytes")
}

record(longout, "ADT:USER1:HDF1:NumExtraDims")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_nExtraDims")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:NumExtraDims_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_nExtraDims")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimSizeN")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimSizeN")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimSizeN_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimSizeN")
    field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:ExtraDimNameN_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimNameN")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimSizeX")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimSizeX")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimSizeX_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimSizeX")
    field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:ExtraDimNameX_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimNameX")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimSizeY")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimSizeY")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimSizeY_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimSizeY")
    field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:ExtraDimNameY_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimNameY")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimSize3")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize3")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimSize3_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize3")
    field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:ExtraDimName3_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimName3")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimSize4")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize4")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimSize4_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize4")
    field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:ExtraDimName4_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimName4")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimSize5")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize5")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimSize5_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize5")
    field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:ExtraDimName5_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimName5")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimSize6")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize6")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimSize6_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize6")
    field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:ExtraDimName6_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimName6")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimSize7")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize7")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimSize7_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize7")
    field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:ExtraDimName7_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimName7")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimSize8")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize8")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimSize8_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize8")
    field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:ExtraDimName8_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimName8")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimSize9")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize9")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimSize9_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimSize9")
    field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:HDF1:ExtraDimName9_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimName9")
    field(SCAN, "I/O Intr")
}

record(bo, "ADT:USER1:HDF1:StoreAttr")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_storeAttributes")
    field(PINI, "YES")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:HDF1:StoreAttr_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_storeAttributes")
    field(SCAN, "I/O Intr")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

record(bo, "ADT:USER1:HDF1:StorePerform")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_storePerformance")
    field(PINI, "YES")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:HDF1:StorePerform_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_storePerformance")
    field(SCAN, "I/O Intr")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

record(ai, "ADT:USER1:HDF1:RunTime")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.hdf,0,1)HDF5_totalRuntime")
    field(SCAN, "I/O Intr")
    field(PREC, "3")
    field(EGU,  "s")
}

record(ai, "ADT:USER1:HDF1:IOSpeed")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.hdf,0,1)HDF5_totalIoSpeed")
    field(SCAN, "I/O Intr")
    field(PREC, "1")
    field(EGU,  "Mbit/s")
}

record(longout, "ADT:USER1:HDF1:NumFramesFlush")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_flushNthFrame")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:NumFramesFlush_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_flushNthFrame")
    field(SCAN, "I/O Intr")
}

record(mbbo, "ADT:USER1:HDF1:Compression")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_compressionType")
    field(PINI, "YES")
    field(ZRST, "None")
    field(ZRVL, "0")
    field(ONST, "N-bit")
    field(ONVL, "1")
    field(TWST, "szip")
    field(TWVL, "2")
    field(THST, "zlib")
    field(THVL, "3")
    field(FRST, "Blosc")
    field(FRVL, "4")
    field(FVST, "BSLZ4")
    field(FVVL, "5")
    field(SXST, "LZ4")
    field(SXVL, "6")
    field(SVST, "JPEG")
    field(SVVL, "7")
    info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:HDF1:Compression_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_compressionType")
    field(SCAN, "I/O Intr")
    field(ZRST, "None")
    field(ZRVL, "0")
    field(ONST, "N-bit")
    field(ONVL, "1")
    field(TWST, "szip")
    field(TWVL, "2")
    field(THST, "zlib")
    field(THVL, "3")
    field(FRST, "Blosc")
    field(FRVL, "4")
    field(FVST, "BSLZ4")
    field(FVVL, "5")
    field(SXST, "LZ4")
    field(SXVL, "6")
    field(SVST, "JPEG")
    field(SVVL, "7")
}

record(longout, "ADT:USER1:HDF1:NumDataBits")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_nbitsPrecision")
    field(PINI, "YES")
    field(EGU,  "bit")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:NumDataBits_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_nbitsPrecision")
    field(SCAN, "I/O Intr")
    field(EGU,  "bit")
}

record(longout, "ADT:USER1:HDF1:DataBitsOffset")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_nbitsOffset")
    field(PINI, "YES")
    field(EGU,  "bit")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:DataBitsOffset_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_nbitsOffset")
    field(SCAN, "I/O Intr")
    field(EGU,  "bit")
}

record(longout, "ADT:USER1:HDF1:SZipNumPixels")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_szipNumPixels")
    field(PINI, "YES")
    field(EGU,  "bit")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:SZipNumPixels_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_szipNumPixels")
    field(SCAN, "I/O Intr")
    field(EGU,  "bit")
}

record(longout, "ADT:USER1:HDF1:ZLevel")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_zCompressLevel")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ZLevel_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_zCompressLevel")
    field(SCAN, "I/O Intr")
}

record(mbbo, "ADT:USER1:HDF1:BloscShuffle")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_bloscShuffleType")
    field(PINI, "YES")
    field(ZRST, "None")
    field(ZRVL, "0")
    field(ONST, "Byte")
    field(ONVL, "1")
    field(TWST, "Bit")
    field(TWVL, "2")
    info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:HDF1:BloscShuffle_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_bloscShuffleType")
    field(SCAN, "I/O Intr")
    field(ZRST, "None")
    field(ZRVL, "0")
    field(ONST, "Byte")
    field(ONVL, "1")
    field(TWST, "Bit")
    field(TWVL, "2")
}

record(mbbo, "ADT:USER1:HDF1:BloscCompressor")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_bloscCompressor")
    field(PINI, "YES")
    field(ZRST, "BloscLZ")
    field(ZRVL, "0")
    field(ONST, "LZ4")
    field(ONVL, "1")
    field(TWST, "LZ4HC")
    field(TWVL, "2")
    field(THST, "SNAPPY")
    field(THVL, "3")
    field(FRST, "ZLIB")
    field(FRVL, "4")
    field(FVST, "ZSTD")
    field(FVVL, "5")
    info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:HDF1:BloscCompressor_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_bloscCompressor")
    field(SCAN, "I/O Intr")
    field(ZRST, "BloscLZ")
    field(ZRVL, "0")
    field(ONST, "LZ4")
    field(ONVL, "1")
    field(TWST, "LZ4HC")
    field(TWVL, "2")
    field(THST, "SNAPPY")
    field(THVL, "3")
    field(FRST, "ZLIB")
    field(FRVL, "4")
    field(FVST, "ZSTD")
    field(FVVL, "5")
}

record(longout, "ADT:USER1:HDF1:BloscLevel")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_bloscCompressLevel")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:BloscLevel_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_bloscCompressLevel")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:JPEGQuality")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_jpegQuality")
    field(VAL, "90")
    field(DRVL, "1")
    field(DRVH, "100")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:JPEGQuality_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_jpegQuality")
    field(SCAN, "I/O Intr")
}

record(bo, "ADT:USER1:HDF1:DimAttDatasets")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_dimAttDatasets")
    field(PINI, "YES")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:HDF1:DimAttDatasets_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_dimAttDatasets")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}

# File path.
# % autosave 2 
#record(waveform, "ADT:USER1:HDF1:XMLPath")
#{
#    field(PINI, "YES")
#    field(DTYP, "asynOctetWrite")
#    field(INP,  "@asyn(SIM.hdf,0,1)HDF5_layoutDirectory")
#    field(FTVL, "CHAR")
#    field(NELM, "256")
#}

record(waveform, "ADT:USER1:HDF1:XMLErrorMsg_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.hdf,0,1)HDF5_layoutErrorMsg")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(bi, "ADT:USER1:HDF1:XMLValid_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.hdf,0,1)HDF5_layoutValid")
    field(ZNAM, "No")
    field(ZSV,  "MAJOR")
    field(ONAM, "Yes")
    field(OSV,  "NO_ALARM")
    field(SCAN, "I/O Intr")
}

# Filename
# % autosave 2 
record(waveform, "ADT:USER1:HDF1:XMLFileName")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.hdf,0,1)HDF5_layoutFilename")
    field(FTVL, "CHAR")
    field(NELM, "2048")
    info(autosaveFields, "VAL")
}

record(waveform, "ADT:USER1:HDF1:XMLFileName_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.hdf,0,1)HDF5_layoutFilename")
    field(FTVL, "CHAR")
    field(NELM, "2048")
    field(SCAN, "I/O Intr")
}

record(bi, "ADT:USER1:HDF1:SWMRSupported_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_SWMRSupported")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Not Supported")
    field(ONAM, "Supported")
}

record(bo, "ADT:USER1:HDF1:SWMRMode")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_SWMRMode")
    field(PINI, "YES")
    field(ZNAM, "Off")
    field(ONAM, "On")
}

record(bi, "ADT:USER1:HDF1:SWMRMode_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_SWMRMode")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Off")
    field(ONAM, "On")
}

record(bi, "ADT:USER1:HDF1:SWMRActive_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_SWMRRunning")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Off")
    field(ONAM, "Active")
}

record(longin, "ADT:USER1:HDF1:SWMRCbCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_SWMRCbCounter")
    field(SCAN, "I/O Intr")
}

record(bo, "ADT:USER1:HDF1:PositionMode")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posRunning")
    field(PINI, "YES")
    field(ZNAM, "Off")
    field(ONAM, "On")
}

record(bi, "ADT:USER1:HDF1:PositionMode_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posRunning")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Off")
    field(ONAM, "On")
}

record(stringout, "ADT:USER1:HDF1:PosNameDimN")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posNameDimN")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosNameDimN_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posNameDimN")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosNameDimX")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posNameDimX")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosNameDimX_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posNameDimX")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosNameDimY")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posNameDimY")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosNameDimY_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posNameDimY")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosNameDim3")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posNameDim3")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosNameDim3_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posNameDim3")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosNameDim4")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posNameDim4")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosNameDim4_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posNameDim4")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosNameDim5")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posNameDim5")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosNameDim5_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posNameDim5")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosNameDim6")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posNameDim6")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosNameDim6_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posNameDim6")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosNameDim7")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posNameDim7")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosNameDim7_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posNameDim7")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosNameDim8")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posNameDim8")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosNameDim8_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posNameDim8")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosNameDim9")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posNameDim9")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosNameDim9_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posNameDim9")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosIndexDimN")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posIndexDimN")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosIndexDimN_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posIndexDimN")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosIndexDimX")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posIndexDimX")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosIndexDimX_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posIndexDimX")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosIndexDimY")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posIndexDimY")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosIndexDimY_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posIndexDimY")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosIndexDim3")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim3")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosIndexDim3_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim3")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosIndexDim4")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim4")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosIndexDim4_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim4")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosIndexDim5")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim5")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosIndexDim5_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim5")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosIndexDim6")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim6")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosIndexDim6_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim6")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosIndexDim7")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim7")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosIndexDim7_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim7")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosIndexDim8")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim8")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosIndexDim8_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim8")
    field(SCAN, "I/O Intr")
}

record(stringout, "ADT:USER1:HDF1:PosIndexDim9")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim9")
    field(PINI, "YES")
}

record(stringin, "ADT:USER1:HDF1:PosIndexDim9_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_posIndexDim9")
    field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:HDF1:FillValue")
{
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(SIM.hdf,0,1)HDF5_fillValue")
    field(PINI, "YES")
    field(PREC, "1")
}

record(ai, "ADT:USER1:HDF1:FillValue_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.hdf,0,1)HDF5_fillValue")
    field(SCAN, "I/O Intr")
    field(PREC, "1")
}

record(longout, "ADT:USER1:HDF1:ExtraDimChunkX")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunkX")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimChunkX_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunkX")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimChunkY")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunkY")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimChunkY_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunkY")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimChunk3")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk3")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimChunk3_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk3")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimChunk4")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk4")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimChunk4_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk4")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimChunk5")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk5")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimChunk5_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk5")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimChunk6")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk6")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimChunk6_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk6")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimChunk7")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk7")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimChunk7_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk7")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimChunk8")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk8")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimChunk8_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk8")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:HDF1:ExtraDimChunk9")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk9")
    field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:HDF1:ExtraDimChunk9_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(SIM.hdf,0,1)HDF5_extraDimChunk9")
    field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDPva.template
# Database for the records specific to the pvAccess plugin
# Bruno Martins
# May 5, 2015

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "ADT:USER1:Pva1:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.pva,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the version of the driver or plugin       #
###################################################################

record(stringin, "ADT:USER1:Pva1:DriverVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.pva,0,1)DRIVER_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "ADT:USER1:Pva1:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.pva,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records contain basic information about the detector     # 
###################################################################

record(stringin, "ADT:USER1:Pva1:Manufacturer_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.pva,0,1)MANUFACTURER")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:Pva1:Model_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.pva,0,1)MODEL")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:Pva1:SerialNumber_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.pva,0,1)SERIAL_NUMBER")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:Pva1:SDKVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.pva,0,1)SDK_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "ADT:USER1:Pva1:FirmwareVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.pva,0,1)FIRMWARE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control acquisition start and stop               #
###################################################################

record(bo, "ADT:USER1:Pva1:Acquire") {
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(SIM.pva,0,1)ACQUIRE")
   field(ZNAM, "Done")
   field(ONAM, "Acquire")
   field(VAL,  "0")
   field(FLNK, "ADT:USER1:Pva1:SetAcquireBusy")
   info(asyn:READBACK, "1")
}

record(bi, "ADT:USER1:Pva1:Acquire_RBV") {
   field(DTYP, "asynInt32")
   field(INP, "@asyn(SIM.pva,0,1)ACQUIRE")
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:Pva1:SetAcquireBusy")
{
    field(INPA, "ADT:USER1:Pva1:Acquire NPP")
    field(CALC, "A")
    field(OOPT, "Transition To Non-zero")
    field(OUT,  "ADT:USER1:Pva1:AcquireBusy PP")
}

record(busy, "ADT:USER1:Pva1:AcquireBusy") {
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(VAL,  "0")
}

record(bi, "ADT:USER1:Pva1:AcquireBusyCB") {
   field(DTYP, "asynInt32")
   field(INP, "@asyn(SIM.pva,0,1)ACQUIRE_BUSY")
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:Pva1:ClearAcquireBusy") {
    field(INPA, "ADT:USER1:Pva1:AcquireBusyCB CP")
    field(CALC, "A")
    field(OOPT, "Transition To Zero")
    field(OUT,  "ADT:USER1:Pva1:AcquireBusy PP")
}

record(bo, "ADT:USER1:Pva1:WaitForPlugins") {
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(SIM.pva,0,1)WAIT_FOR_PLUGINS")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(VAL,  "0")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longout, "ADT:USER1:Pva1:NDimensions")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)ARRAY_NDIMENSIONS")
}

record(longin, "ADT:USER1:Pva1:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform records
record(waveform, "ADT:USER1:Pva1:Dimensions")
{
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(SIM.pva,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "ADT:USER1:Pva1:Dim0SA")
}

record(subArray, "ADT:USER1:Pva1:Dim0SA")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "ADT:USER1:Pva1:ArraySize0")
}

record(longin, "ADT:USER1:Pva1:ArraySize0")
{
    field(INP,  "ADT:USER1:Pva1:Dim0SA")
    field(FLNK, "ADT:USER1:Pva1:Dim1SA")
}

record(subArray, "ADT:USER1:Pva1:Dim1SA")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "ADT:USER1:Pva1:ArraySize1")
}

record(longin, "ADT:USER1:Pva1:ArraySize1")
{
    field(INP,  "ADT:USER1:Pva1:Dim1SA")
    field(FLNK, "ADT:USER1:Pva1:Dim2SA")
}

record(subArray, "ADT:USER1:Pva1:Dim2SA")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "ADT:USER1:Pva1:ArraySize2")
}

record(longin, "ADT:USER1:Pva1:ArraySize2")
{
    field(INP,  "ADT:USER1:Pva1:Dim2SA")
    field(FLNK, "ADT:USER1:Pva1:Dim3SA")
}

record(subArray, "ADT:USER1:Pva1:Dim3SA")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "3")
    field(FLNK, "ADT:USER1:Pva1:ArraySize3")
}

record(longin, "ADT:USER1:Pva1:ArraySize3")
{
    field(INP,  "ADT:USER1:Pva1:Dim3SA")
    field(FLNK, "ADT:USER1:Pva1:Dim4SA")
}

record(subArray, "ADT:USER1:Pva1:Dim4SA")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "4")
    field(FLNK, "ADT:USER1:Pva1:ArraySize4")
}

record(longin, "ADT:USER1:Pva1:ArraySize4")
{
    field(INP,  "ADT:USER1:Pva1:Dim4SA")
    field(FLNK, "ADT:USER1:Pva1:Dim5SA")
}

record(subArray, "ADT:USER1:Pva1:Dim5SA")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "5")
    field(FLNK, "ADT:USER1:Pva1:ArraySize5")
}

record(longin, "ADT:USER1:Pva1:ArraySize5")
{
    field(INP,  "ADT:USER1:Pva1:Dim5SA")
    field(FLNK, "ADT:USER1:Pva1:Dim6SA")
}

record(subArray, "ADT:USER1:Pva1:Dim6SA")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "6")
    field(FLNK, "ADT:USER1:Pva1:ArraySize6")
}

record(longin, "ADT:USER1:Pva1:ArraySize6")
{
    field(INP,  "ADT:USER1:Pva1:Dim6SA")
    field(FLNK, "ADT:USER1:Pva1:Dim7SA")
}

record(subArray, "ADT:USER1:Pva1:Dim7SA")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "7")
    field(FLNK, "ADT:USER1:Pva1:ArraySize7")
}

record(longin, "ADT:USER1:Pva1:ArraySize7")
{
    field(INP,  "ADT:USER1:Pva1:Dim7SA")
    field(FLNK, "ADT:USER1:Pva1:Dim8SA")
}

record(subArray, "ADT:USER1:Pva1:Dim8SA")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "8")
    field(FLNK, "ADT:USER1:Pva1:ArraySize8")
}

record(longin, "ADT:USER1:Pva1:ArraySize8")
{
    field(INP,  "ADT:USER1:Pva1:Dim8SA")
    field(FLNK, "ADT:USER1:Pva1:Dim9SA")
}

record(subArray, "ADT:USER1:Pva1:Dim9SA")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "9")
    field(FLNK, "ADT:USER1:Pva1:ArraySize9")
}

record(longin, "ADT:USER1:Pva1:ArraySize9")
{
    field(INP,  "ADT:USER1:Pva1:Dim9SA")
}


record(waveform, "ADT:USER1:Pva1:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(SIM.pva,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "ADT:USER1:Pva1:Dim0SA_RBV")
    field(SCAN, "I/O Intr")
}

record(subArray, "ADT:USER1:Pva1:Dim0SA_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "ADT:USER1:Pva1:ArraySize0_RBV")
}

record(longin, "ADT:USER1:Pva1:ArraySize0_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dim0SA_RBV")
    field(FLNK, "ADT:USER1:Pva1:Dim1SA_RBV")
}

record(subArray, "ADT:USER1:Pva1:Dim1SA_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "ADT:USER1:Pva1:ArraySize1_RBV")
}

record(longin, "ADT:USER1:Pva1:ArraySize1_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dim1SA_RBV")
    field(FLNK, "ADT:USER1:Pva1:Dim2SA_RBV")
}

record(subArray, "ADT:USER1:Pva1:Dim2SA_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "ADT:USER1:Pva1:ArraySize2_RBV")
}

record(longin, "ADT:USER1:Pva1:ArraySize2_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dim2SA_RBV")
    field(FLNK, "ADT:USER1:Pva1:Dim3SA_RBV")
}

record(subArray, "ADT:USER1:Pva1:Dim3SA_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "3")
    field(FLNK, "ADT:USER1:Pva1:ArraySize3_RBV")
}

record(longin, "ADT:USER1:Pva1:ArraySize3_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dim3SA_RBV")
    field(FLNK, "ADT:USER1:Pva1:Dim4SA_RBV")
}

record(subArray, "ADT:USER1:Pva1:Dim4SA_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "4")
    field(FLNK, "ADT:USER1:Pva1:ArraySize4_RBV")
}

record(longin, "ADT:USER1:Pva1:ArraySize4_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dim4SA_RBV")
    field(FLNK, "ADT:USER1:Pva1:Dim5SA_RBV")
}

record(subArray, "ADT:USER1:Pva1:Dim5SA_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "5")
    field(FLNK, "ADT:USER1:Pva1:ArraySize5_RBV")
}

record(longin, "ADT:USER1:Pva1:ArraySize5_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dim5SA_RBV")
    field(FLNK, "ADT:USER1:Pva1:Dim6SA_RBV")
}

record(subArray, "ADT:USER1:Pva1:Dim6SA_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "6")
    field(FLNK, "ADT:USER1:Pva1:ArraySize6_RBV")
}

record(longin, "ADT:USER1:Pva1:ArraySize6_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dim6SA_RBV")
    field(FLNK, "ADT:USER1:Pva1:Dim7SA_RBV")
}

record(subArray, "ADT:USER1:Pva1:Dim7SA_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "7")
    field(FLNK, "ADT:USER1:Pva1:ArraySize7_RBV")
}

record(longin, "ADT:USER1:Pva1:ArraySize7_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dim7SA_RBV")
    field(FLNK, "ADT:USER1:Pva1:Dim8SA_RBV")
}

record(subArray, "ADT:USER1:Pva1:Dim8SA_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "8")
    field(FLNK, "ADT:USER1:Pva1:ArraySize8_RBV")
}

record(longin, "ADT:USER1:Pva1:ArraySize8_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dim8SA_RBV")
    field(FLNK, "ADT:USER1:Pva1:Dim9SA_RBV")
}

record(subArray, "ADT:USER1:Pva1:Dim9SA_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "9")
    field(FLNK, "ADT:USER1:Pva1:ArraySize9_RBV")
}

record(longin, "ADT:USER1:Pva1:ArraySize9_RBV")
{
    field(INP,  "ADT:USER1:Pva1:Dim9SA_RBV")
}


record(mbbi, "ADT:USER1:Pva1:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.pva,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:Pva1:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.pva,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:Pva1:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.pva,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:Pva1:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.pva,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:Pva1:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.pva,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records have information on the compression              # 
###################################################################
record(stringin, "ADT:USER1:Pva1:Codec_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.pva,0,1)CODEC")
   field(VAL,  "")
   field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:Pva1:CompressedSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.pva,0,1)COMPRESSED_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "ADT:USER1:Pva1:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.pva,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Int64")
   field(SXVL, "6")
   field(SVST, "UInt64")
   field(SVVL, "7")
   field(EIST, "Float32")
   field(EIVL, "8")
   field(NIST, "Float64")
   field(NIVL, "9")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:Pva1:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.pva,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Int64")
   field(SXVL, "6")
   field(SVST, "UInt64")
   field(SVVL, "7")
   field(EIST, "Float32")
   field(EIVL, "8")
   field(NIST, "Float64")
   field(NIVL, "9")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "ADT:USER1:Pva1:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.pva,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "ADT:USER1:Pva1:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.pva,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "ADT:USER1:Pva1:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "ADT:USER1:Pva1:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.pva,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:Pva1:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:Pva1:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "ADT:USER1:Pva1:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)ARRAY_COUNTER")
}

record(longin, "ADT:USER1:Pva1:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "ADT:USER1:Pva1:ArrayRate_RBV")
{
    field(INPA, "ADT:USER1:Pva1:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "ADT:USER1:Pva1:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "ADT:USER1:Pva1:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "ADT:USER1:Pva1:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Enable")
    field(OSV,  "MINOR")
    field(VAL, "1")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:Pva1:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Enable")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains macro definitions for the attributes      # 
###################################################################

record(waveform, "ADT:USER1:Pva1:NDAttributesMacros")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.pva,0,1)ND_ATTRIBUTES_MACROS")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  This record is the name of a file defining attributes          # 
###################################################################

record(waveform, "ADT:USER1:Pva1:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(SIM.pva,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  This record defines the status of reading attributes file      # 
###################################################################

record(mbbi, "ADT:USER1:Pva1:NDAttributesStatus")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)ND_ATTRIBUTES_STATUS")
    field(ZRVL, "0")
    field(ZRST, "Attributes file OK")
    field(ZRSV, "NO_ALARM")
    field(ONVL, "1")
    field(ONST, "File not found")
    field(ONSV, "MINOR")
    field(TWVL, "2")
    field(TWST, "XML syntax error")
    field(TWSV, "MAJOR")
    field(THVL, "3")
    field(THST, "Macro substitution error")
    field(THSV, "MAJOR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "ADT:USER1:Pva1:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.pva,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "ADT:USER1:Pva1:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(SIM.pva,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "ADT:USER1:Pva1:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "ADT:USER1:Pva1:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.pva,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "ADT:USER1:Pva1:PoolFreeBuffers")
}

record(longin, "ADT:USER1:Pva1:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.pva,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "ADT:USER1:Pva1:PoolUsedBuffers")
}

record(calc, "ADT:USER1:Pva1:PoolUsedBuffers")
{
    field(INPA, "ADT:USER1:Pva1:PoolAllocBuffers NPP MS")
    field(INPB, "ADT:USER1:Pva1:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

record(bo, "ADT:USER1:Pva1:EmptyFreeList")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(SIM.pva,0,1)POOL_EMPTY_FREELIST")
}

record(longin, "ADT:USER1:Pva1:NumQueuedArrays")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(SIM.pva,0,1)NUM_QUEUED_ARRAYS")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "ADT:USER1:Pva1:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(SIM.pva,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "ADT:USER1:Pva1:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(SIM.pva,0,1)NDARRAY_PORT")
    field(VAL,  "SIM.CAM")
    info(autosaveFields, "VAL")
}

record(stringin, "ADT:USER1:Pva1:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.pva,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:Pva1:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "ADT:USER1:Pva1:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "ADT:USER1:Pva1:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "1")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:Pva1:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:Pva1:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(SIM.pva,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    field(DRVL, "0")
    info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:Pva1:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.pva,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:Pva1:MaxArrayRate")
{
    field(DTYP, "Soft Channel")
    field(OUT,  "ADT:USER1:Pva1:MaxArrayRate_COUT PP")
    field(EGU,  "Hz")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(calcout, "ADT:USER1:Pva1:MaxArrayRate_COUT")
{
    field(INPA, "ADT:USER1:Pva1:MaxArrayRate")
    field(CALC, "A=0?0:1.0/A")
    field(OUT,  "ADT:USER1:Pva1:MinCallbackTime PP")
}

record(calc, "ADT:USER1:Pva1:MaxArrayRate_RBV")
{
    field(INPA, "ADT:USER1:Pva1:MinCallbackTime_RBV CP")
    field(CALC, "A=0?0:1.0/A")
    field(EGU,  "Hz")
    field(PREC, "3")
    field(SCAN, "Passive")
}

record(ao, "ADT:USER1:Pva1:MaxByteRate")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(SIM.pva,0,1)MAX_BYTE_RATE")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    field(DRVL, "0")
    info(autosaveFields, "VAL")
}

record(ai, "ADT:USER1:Pva1:MaxByteRate_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.pva,0,1)MAX_BYTE_RATE")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the last execution time of the plugin     #
###################################################################
record(ai, "ADT:USER1:Pva1:ExecutionTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.pva,0,1)EXECUTION_TIME")
    field(EGU,  "ms")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record requests that the plugin execute again with the    #
#  same NDArray                                                   #
###################################################################
record(bo, "ADT:USER1:Pva1:ProcessPlugin")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)PROCESS_PLUGIN")
    field(VAL,  "1")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "ADT:USER1:Pva1:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "ADT:USER1:Pva1:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "ADT:USER1:Pva1:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "ADT:USER1:Pva1:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:Pva1:QueueSize")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)QUEUE_SIZE")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:Pva1:QueueSize_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)QUEUE_SIZE")
    field(FLNK, "ADT:USER1:Pva1:QueueFreeLow")
    field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:Pva1:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "ADT:USER1:Pva1:QueueSize")
    field(OUT,  "ADT:USER1:Pva1:QueueFree.LOW")
    field(FLNK, "ADT:USER1:Pva1:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "ADT:USER1:Pva1:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "ADT:USER1:Pva1:QueueSize")
   field(OUT,  "ADT:USER1:Pva1:QueueUse.HIGH")
   field(FLNK, "ADT:USER1:Pva1:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "ADT:USER1:Pva1:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "ADT:USER1:Pva1:QueueSize")
   field(OUT,  "ADT:USER1:Pva1:QueueUse.HIHI")
}

record(longin, "ADT:USER1:Pva1:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "ADT:USER1:Pva1:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "ADT:USER1:Pva1:QueueSize")
    field(INPB, "ADT:USER1:Pva1:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}

record(longout, "ADT:USER1:Pva1:NumThreads")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)NUM_THREADS")
    field(VAL,  "1")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:Pva1:NumThreads_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)NUM_THREADS")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:Pva1:MaxThreads_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)MAX_THREADS")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control output array sorting                     #
###################################################################
record(mbbo, "ADT:USER1:Pva1:SortMode") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)SORT_MODE")
    field(ZRVL, "0")
    field(ZRST, "Unsorted")
    field(ONVL, "1")
    field(ONST, "Sorted")
}

record(mbbi, "ADT:USER1:Pva1:SortMode_RBV") {
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)SORT_MODE")
    field(ZRVL, "0")
    field(ZRST, "Unsorted")
    field(ONVL, "1")
    field(ONST, "Sorted")
    field(SCAN, "I/O Intr")
}

record(ao, "ADT:USER1:Pva1:SortTime") {
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(SIM.pva,0,1)SORT_TIME")
    field(PREC, "3")
    field(VAL, "0.1")
}

record(ai, "ADT:USER1:Pva1:SortTime_RBV") {
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(SIM.pva,0,1)SORT_TIME")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:Pva1:SortSize")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)SORT_SIZE")
    field(VAL,  "20")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:Pva1:SortSize_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)SORT_SIZE")
    field(FLNK, "ADT:USER1:Pva1:SortFreeLow")
    field(SCAN, "I/O Intr")
}

record(longin, "ADT:USER1:Pva1:SortFree") {
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)SORT_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

record(calcout, "ADT:USER1:Pva1:SortFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "ADT:USER1:Pva1:SortSize")
    field(OUT,  "ADT:USER1:Pva1:SortFree.LOW")
}

record(longout, "ADT:USER1:Pva1:DroppedOutputArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)DROPPED_OUTPUT_ARRAYS")
    field(VAL,  "0")
}

record(longin, "ADT:USER1:Pva1:DroppedOutputArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)DROPPED_OUTPUT_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longout, "ADT:USER1:Pva1:DisorderedArrays")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(SIM.pva,0,1)DISORDERED_ARRAYS")
    field(PINI, "YES")
}

record(longin, "ADT:USER1:Pva1:DisorderedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(SIM.pva,0,1)DISORDERED_ARRAYS")
    field(SCAN, "I/O Intr")
}



###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"ADT:USER1:Pva1:AsynIO")
{
    field(PORT, "SIM.pva")
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


# New records for NDPluginPva

record(waveform, "ADT:USER1:Pva1:PvName_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(SIM.pva,0,1)PV_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}
